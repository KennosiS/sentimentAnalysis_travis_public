'use strict';

var Cache = require('lru-cache');
var Polling = require('./Polling');
var userInput = require('./user-input');
var RestAdapter = require('./RestAdapter');
var INSTANCE = require('./constants').STATUS.INSTANCE;
var debug = require('debug')('instance-manager');

module.exports = InstanceManager;

function InstanceManager(options) {
  this._adapter = new RestAdapter(options);
  this._polling = new Polling(this._adapter, options.polling_interval_millis, options.polling_timeout_seconds);
  this._cache = new Cache({ max: options.cache_max_items, maxAge: (options.cache_item_expire_seconds * 1000) });
}

InstanceManager.prototype._fillInCache = function (callback) {
  var self = this;
  this._adapter.getAllInstances(function (err, instances) {
    if (err) {
      return callback(err);
    }
    instances.filter(function (instance) {
      return instance.status === INSTANCE.CREATED;
    }).forEach(function (instance) {
      self._cache.set(instance.tenant_id, instance);
    });
    callback(null);
  });
};

InstanceManager.prototype.create = function (tenant, callback) {
  tenant = userInput.processTenant(tenant);

  var self = this;
  this._adapter.initCreateInstance(tenant, function (err) {
    if (err) {
      return callback(err);
    }
    pollUntilCreated(self, tenant, callback);
  });
};

InstanceManager.prototype.get = function (tenant, callback) {
  tenant = userInput.processTenant(tenant);

  var self = this;
  if (this._cache.has(tenant)) {
    debug("Getting instance for tenant '%s' from cache", tenant);
    return process.nextTick(function () { callback(null, self._cache.get(tenant)); });
  }

  this._adapter.getInstance(tenant, function (err, instance) {
    if (err) {
      return callback(err);
    }
    if (!instance) {
      return callback(null, null);
    }
    if (instance.status === INSTANCE.CREATING) {
      return pollUntilCreated(self, tenant, callback);
    }
    callback(null, instance);
  });
};

InstanceManager.prototype.delete = function (tenant, callback) {
  tenant = userInput.processTenant(tenant);

  var self = this;
  this._adapter.initDeleteInstance(tenant, function (err) {
    if (err) {
      return callback(err);
    }
    pollUntilDeleted(self, tenant, callback);
  });
};

function pollUntilCreated(self, tenant, cb) {
  self._polling.untilCreated(tenant, function (err, instance) {
    if (err) {
      return cb(err);
    }
    self._cache.set(instance.tenant_id, instance);
    cb(null, instance);
  });
}

function pollUntilDeleted(self, tenant, cb) {
  self._polling.untilDeleted(tenant, function (err) {
    self._cache.del(tenant);
    cb(err);
  });
}
