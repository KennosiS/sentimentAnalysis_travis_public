'use strict';

var async = require('async');
var debug = require('debug')('hdbext:sp');
var util = require('util');
var VError = require('verror');
var clientSession = require('./client-session');

module.exports.load = load;


function execWithPrepare(client, sql, args, cb) {
  client.prepare(sql, function (err, statement) {
    if (err) {
      return cb(err);
    }
    statement.exec(args, cb);
  });
}

function load(client, schema, name, cb) {
  async.waterfall([
    /* Find the schema name */
    function(callback) {
      if (schema) {
        return callback(null, schema);
      }
      return clientSession.getSchema(client, callback);
    },

    /* Check the parameter metadata and create the result set */
    function(schema, callback) {
      var sql = 'SELECT PARAMETER_NAME, DATA_TYPE_NAME, PARAMETER_TYPE, IS_INPLACE_TYPE, TABLE_TYPE_SCHEMA, TABLE_TYPE_NAME' +
        ' FROM SYS.PROCEDURE_PARAMETERS WHERE SCHEMA_NAME= ? AND PROCEDURE_NAME = ? ORDER BY POSITION';

      execWithPrepare(client, sql, [schema, name], function(err, paramsMetadata) {
        if (err) {
          return callback(err);
        }
        var hasTableParameters = paramsMetadata.some(function(i) {
          return i.PARAMETER_TYPE === 'IN' && i.DATA_TYPE_NAME === 'TABLE_TYPE';
        });

        var res = new StoredProcedure(client, paramsMetadata, name, schema);
        var spFunction = res.exec.bind(res);
        spFunction.paramsMetadata = res._paramsMetadata;

        if (hasTableParameters) {
          // input table parameters cannot be bound with '?'
          // so we have to prepare a new statement for each call
          return callback(null, spFunction);
        }
        var sql = util.format('CALL "%s"."%s"(%s)',
          schema, name, paramsMetadata.map(function() { return '?'; }).join(','));
        debug(sql);
        client.prepare(sql, function(err, st) {
          if (err) {
            return callback(err, null);
          }
          res.setStatement(st);
          callback(null, spFunction);
        });
      });
    }
  ],
  cb);
}

function StoredProcedure(client, paramsMetadata, name, schema) {
  this._client            = client;
  this._paramsMetadata    = paramsMetadata;
  this._name              = name;
  this._schema            = schema;
}


StoredProcedure.prototype.setStatement = function(statement) {
  this._statement         = statement;
};

StoredProcedure.prototype.exec = function(params, cb) {
  var self        = this;
  var args        = Array.prototype.slice.call(arguments);
  var tempTables  = [];
  var spInput     = {};
  cb              = args.pop();

  if (this._statement) {
    if (args.length === 1 && (Array.isArray(args[0]) || typeof args[0] === 'object')) {
      spInput = args[0];
    } else {
      spInput = args;
    }
    self._statement.exec(spInput, function() {
      cb.apply(null, arguments);
    });
    return;
  }

  if (!args.length) {
    return cb(new Error('Stored procedure ' + this._name + ' expects input parameters'));
  }
  var c = 0;
  var inparamPos = this._paramsMetadata.filter(function(a) {
    return a.PARAMETER_TYPE === 'IN' || a.PARAMETER_TYPE === 'INOUT';
  }).reduce(function(p, a) {
    p[a.PARAMETER_NAME] = c++;
    return p;
  }, {});

  try {
    var sql = util.format('CALL "%s"."%s"(%s)', this._schema, this._name,
      this._paramsMetadata.map(getCallArgument).join(','));
    debug(sql);
  } catch (err) {
    return cb(err);
  }
  async.waterfall([
    createTempTables,
    prepareCall,
    executeCall
  ], function () {
    // always clean up
    self._dropTables(tempTables);
    cb.apply(null, arguments);
  });

  function getCallArgument(a) {
    if (a.PARAMETER_TYPE === 'IN' || a.PARAMETER_TYPE === 'INOUT') {
      var paramData = args.length === 1 ? args[0][a.PARAMETER_NAME] || args[0]
                                        : args[inparamPos[a.PARAMETER_NAME]];
      if (a.DATA_TYPE_NAME === 'TABLE_TYPE') {
        if (typeof paramData === 'string') {
          return paramData; // table name provided
        }
        if (!Array.isArray(paramData)) {
          throw new Error('Table parameter ' + a.PARAMETER_NAME +
            ' is expected to be an array of objects');
        }
        var tempTable = '"#' + self._name + '_' + a.PARAMETER_NAME + '_' +
          Math.floor(Math.random() * 1000) + Date.now() + '"';
        tempTables.push({
          name: tempTable,
          metadata: a,
          data: paramData
        });
        return tempTable;
      }
      spInput[a.PARAMETER_NAME] = paramData;
    }
    return '?';
  }

  function createTempTables(cb) {
    function createTable(table, callback) {
      self._createTempTable(table.name, table.metadata, table.data, function(err) {
        callback(err && new VError(err, 'Could not create temporary table ' + table.name));
      });
    }
    async.each(tempTables, createTable, cb);
  }

  function prepareCall(cb) {
    self._client.prepare(sql, cb);
  }

  function executeCall(statement, cb) {
    statement.exec(spInput, cb);
  }
};

StoredProcedure.prototype._dropTables = function(tables) {
  var self = this;
  tables.forEach(function(t) {
    var sql = 'drop table ' + t.name;
    debug(sql);
    self._client.execute(sql, function(err) {
      if (err) {
        debug(sql, err);
      }
    });
  });
};

StoredProcedure.prototype._insertIntoTable = function(table, input, cb) {
  var self = this;
  var fields = Object.keys(input[0]);

  var escapedFields = fields.map(function (field) {
    return '"' + field + '"';
  }).join(',');
  var questionMarksForFields = fields.map(function () {
    return '?';
  }).join(',');

  var sqlIns = 'insert into ' + table + '(' + escapedFields + ')' + ' values (' + questionMarksForFields + ')';
  debug(sqlIns);
  self._client.prepare(sqlIns, function(err, insStatement) {
    if (err) {
      return cb(err, null);
    }
    var insVals = input.map(function(p) { return Object.keys(p).map(function(x) { return p[x]; }); });
    insStatement.execute(insVals, function(err){
      return cb(err);
    });
  });
};

StoredProcedure.prototype._createTempTable = function(tempTable, metadata, input, cb) {
  var self = this;
  generateCreateTempTableSql(this, tempTable, metadata, function (err, sql) {
    if (err) {
      return cb(err);
    }

    debug(sql);
    self._client.execute(sql, function (err) {
      if (err) {
        return cb(err);
      }
      if (!input.length || !Object.keys(input[0]).length) {
        return cb();
      }

      return self._insertIntoTable(tempTable, input, cb);
    });
  });
};

function generateCreateTempTableSql(sp, tempTable, metadata, cb) {
  if (metadata.IS_INPLACE_TYPE === 'FALSE') {
    return cb(null, 'create local temporary table ' + tempTable + ' like "' +
      metadata.TABLE_TYPE_SCHEMA + '"."' + metadata.TABLE_TYPE_NAME + '"');
  }

  var columnDefinitions = [];
  var inplaceTableMetadataSql = 'SELECT COLUMN_NAME, DATA_TYPE_NAME, LENGTH, SCALE FROM SYS.PROCEDURE_PARAMETER_COLUMNS \
     WHERE SCHEMA_NAME = ? AND PROCEDURE_NAME = ? AND PARAMETER_NAME = ? ORDER BY POSITION';
  execWithPrepare(sp._client, inplaceTableMetadataSql, [sp._schema, sp._name, metadata.PARAMETER_NAME], function (err, rs) {
    if (err) {
      return cb(err);
    }
    rs.forEach(function (row) {
      // Reference: https://help.sap.com/saphelp_hanaplatform/helpdata/en/20/d58a5f75191014b2fe92141b7df228/frameset.htm
      var str = util.format('"%s" %s', row.COLUMN_NAME, row.DATA_TYPE_NAME);
      switch (row.DATA_TYPE_NAME) {
      case 'DECIMAL':
        str += '(' + row.LENGTH;
        if (row.SCALE !== null) {
          str += ', ' + row.SCALE;
        }
        str += ')';
        break;
      case 'CHAR':
      case 'NCHAR':
      case 'VARCHAR':
      case 'NVARCHAR':
      case 'ALPHANUM':
      case 'BINARY':
      case 'VARBINARY':
      case 'SHORTTEXT':
      // FLOAT data type is represented as REAL or DOUBLE in the database
        str += '(' + row.LENGTH + ')';
        break;
      }
      columnDefinitions.push(str);
    });

    var sColumnDefinitions = columnDefinitions.join(', ');
    cb(null, 'CREATE LOCAL TEMPORARY TABLE ' + tempTable + ' (' + sColumnDefinitions + ')');
  });
}
