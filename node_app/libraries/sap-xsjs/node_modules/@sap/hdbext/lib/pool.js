'use strict';

var _ = require('lodash');
var async = require('async');
var crypto = require('crypto');
var util = require('util');
var constants = require('./constants');
var factory = require('./client-factory');
var clientSession = require('./client-session');
var logger = require('./utils/logger').getLogger();
var INSUFFICIENT_PRIVILEGE_ERROR_CODE = 258;

var poolModule = require('generic-pool');
var LRU = require('lru-cache'),
  cache = LRU({
    max: 10,
    dispose: function (key, pool) {
      drainPool(pool);
    }
  });

exports.getPool = getPool;

function getPool(hanaService, options) {
  var key = hanaService.host + ':' + hanaService.port + ':' + hanaService.assertion + ':' + hanaService.user + ':' + hanaService.password;
  key = crypto.createHash('sha1').update(key).digest('hex');
  var pool = cache.get(key);
  if (!pool) {
    pool = createPool(hanaService, options);
    cache.set(key, pool);
  }

  function releaseToPool(client) {

    function handleError(err) {
      if (err.code === INSUFFICIENT_PRIVILEGE_ERROR_CODE) {
        // Currently the 'user' from the service binding does not have the privileges required to access the view with the list of temporary tables.
        // Connection will be terminated in order not to be reused. Logging on level debug in order not to flood the logs.
        // Corresponding privileges will be added to the user in the service binding.
        logger.debug(err, 'SAP_HDBEXT POOL: could not reset connection');
      } else {
        logger.error(err, 'SAP_HDBEXT POOL: could not reset connection');
      }
      pool.destroy(client);
    }

    client.emit('release');
    client.removeAllListeners();

    async.series([
      function (cb) {
        client.rollback(cb);
      },
      function (cb) {
        clientSession.unsetSessionVariables(client, client._connectionInitialSettings.updatedOptions.session, cb);
      },
      function (cb) {
        clientSession.updateConnectionOptions(client, {
          isolationLevel: client._connectionInitialSettings.isolationLevel,
          schema: client._connectionInitialSettings.currentSchema,
          locale: client._connectionInitialSettings.locale
        }, cb);
      }
    ], function (err) {
      if (err) {
        return handleError(err);
      }

      async.waterfall([
        client.exec.bind(client, 'SELECT SCHEMA_NAME, TABLE_NAME FROM M_TEMPORARY_TABLES WHERE CONNECTION_ID = CURRENT_CONNECTION'),
        function (rs, cb) {
          async.each(rs, function (row, eachCb) {
            client.exec(util.format('DROP TABLE "%s"."%s" CASCADE', row.SCHEMA_NAME, row.TABLE_NAME), eachCb);
          }, cb);
        },
        function (cb) {
          client.commit(cb);
        }
      ], function (err) {
        if (err) {
          return handleError(err);
        }
        pool.release(client);
      });
    });
  }

  return {
    acquire: function (options, callback) {
      if (arguments.length === 1) {
        callback = arguments[0];
        options = {};
      }
      options = options || {};
      pool.acquire(function (err, client) {
        if (err) {
          return callback(err);
        }

        client.close = releaseToPool.bind(null, client);
        client.disconnect = releaseToPool.bind(null, client);
        client.on('close', pool.destroy.bind(null, client));

        client._connectionInitialSettings.updatedOptions = {
          autoCommit: _.isNil(options.autoCommit) ? client._connectionInitialSettings.autoCommit : options.autoCommit,
          locale: options.locale || client._connectionInitialSettings.locale,
          schema: '',
          session: _.extend({}, client._connectionInitialSettings.session, options.session)
        };
        if (options.schema &&
          options.schema !== client._connectionInitialSettings.schema &&
          options.schema !== client._connectionInitialSettings.currentSchema) {
          client._connectionInitialSettings.updatedOptions.schema = options.schema;
        }
        if (options.isolationLevel && options.isolationLevel !== client._connectionInitialSettings.isolationLevel) {
          client._connectionInitialSettings.updatedOptions.isolationLevel = options.isolationLevel;
        }
        clientSession.updateConnectionOptions(client, client._connectionInitialSettings.updatedOptions, function (err) {
          callback(err, client);
        });
      });
    },
    release: releaseToPool,
    drain: drainPool.bind(null, pool)
  };
}

function drainPool(pool) {
  pool.drain(function () {
    pool.destroyAllNow();
  });
}

function createPool(hanaService, options) {
  logger.debug('SAP_HDBEXT POOL: create pool');
  var defaultOptions = {
    max: 100,
    min: 1,
    idleTimeoutMillis: 30000,
    log: false,
    refreshIdle: false
  };

  options = _.extend(defaultOptions, options);

  var pool = poolModule.Pool({
    name: 'hana',
    create: function (callback) {
      logger.debug('SAP_HDBEXT POOL: create in pool');
      factory.createConnection(hanaService, function (err, client) {
        if (err) {
          return callback(err);
        }

        client._connectionInitialSettings = {
          autoCommit: _.isNil(hanaService.autoCommit) || !!hanaService.autoCommit,
          locale: hanaService.locale || client.connectOptions.clientLocale,
          isolationLevel: hanaService.isolationLevel || constants.isolation['READ_COMMITTED'],
          schema: hanaService.schema,
          session: hanaService.session || {}
        };
        clientSession.getSchema(client, function (err, schema) {
          client._connectionInitialSettings.currentSchema = schema;
          callback(err, client);
        });
      });
    },
    destroy: function (client) {
      logger.debug('SAP_HDBEXT POOL: destroy in pool');
      client._connection.close();
    },
    validate: function (client) {
      return client.readyState === 'connected';
    },
    max: options.max,
    min: options.min,
    idleTimeoutMillis: options.idleTimeoutMillis,
    log: options.log,
    refreshIdle: options.refreshIdle,
    reapIntervalMillis: options.reapIntervalMillis,
    returnToHead: options.returnToHead,
    priorityRange: options.priorityRange
  });
  return pool;
}
