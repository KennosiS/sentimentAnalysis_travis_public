'use strict';

//Include
var sql = require('./sqlStatement');
var sqlTools = require('./sqlTools');
var addETagToSelect = sql._addETagToSelect;
var utils = require('../utils/utils');

//Code
exports.createPostStatements = function (context, asyncDone) {
    try {
        context.logger.silly('sqlCollector', 'createGetSqlStatements');
        var dbSegLast = context.oData.dbSegmentLast;

        var sqlContext = {
            context: context,
            netId: context.uniqueNetworkRequestID,
            reqId: context.uniqueRequestID,
            rId: 1,
            dbSegLast: dbSegLast,
            systemQueryParameters: context.oData.systemQueryParameters
        };

        context.sql = sqlContext;

        context.sql.container = dbSegLast.sql.stmContainer = new sql.PostContainer();

        startPostMasterDbSeg(sqlContext);
        return asyncDone(null, context);
    } catch (err) {
        return asyncDone(err, context);
    }
};

/**
 * Create SQL statements for the master table (=end of resource path)
 * @param sqlContext
 */
function startPostMasterDbSeg(sqlContext) {
    var dbSeg = sqlContext.dbSegLast;

    sqlContext.context.logger.debug('sqlCollector', 'startGetMasterDbSeg');

    dbSeg.sql.rId = sqlTools.rIdToNewTableName(dbSeg._Alias, sqlContext.netId, sqlContext.reqId, sqlContext.rId++);

    //create statement for master table
    dbSeg.sql.stmContainer.createTmp = masterTableCreate(sqlContext, dbSeg.sql.rId);

    //create insert statement for master table
    dbSeg.sql.stmContainer.insertTmp = masterTableInsertTmp(sqlContext, dbSeg.sql.rId);

    //create insert statement for master table
    dbSeg.sql.stmContainer.insertReal = masterTableInsert(sqlContext, dbSeg.sql.rId);

    //create select statement for master table
    dbSeg.sql.stmContainer.select = masterTableSelect(sqlContext, dbSeg.sql.rId);

    if (sqlContext.context.db.isExternalHandledConnection === true) {
        // We only truncate and delete temp tables when db connection is handled external
        // otherwise we will self disconnect and temp tables will be deleted automatically

        // Build the truncate statement for created temporary table;
        dbSeg.sql.stmContainer.createTmpTruncate = sql.buildTableStatement(sql.Truncate, sqlContext,
            dbSeg.sql.stmContainer.createTmp.table);
        sqlContext.context.networkContext.cleanSessionTruncateContainer.push(dbSeg.sql.stmContainer.createTmpTruncate);

        // Build the drop statement for created temporary table;
        dbSeg.sql.stmContainer.createTmpDrop = sql.buildTableStatement(sql.Drop, sqlContext,
            dbSeg.sql.stmContainer.createTmp.table);
        sqlContext.context.networkContext.cleanSessionDropContainer.push(dbSeg.sql.stmContainer.createTmpDrop);
    }
}

function masterTableCreate(sqlContext, rId) {
    sqlContext.context.logger.debug('sqlCollector', 'masterTableCreate');
    var dbSeg = sqlContext.dbSegLast;
    var stmCreate = new sql.Create();
    stmCreate.setModifiers(['local', 'temporary', dbSeg.entityType.tableStoreType]);
    stmCreate.setTableName(rId);

    stmCreate.addProperties(dbSeg.getPropertiesForCreate());
    if (dbSeg._ExpandedNavigations.length > 0) {
        stmCreate.addProperties(dbSeg.getNavPropertiesForCreate());
    }
    return stmCreate;

    /*
     var stmCreate = new sql.Create();
     stmCreate.setModifiers(['local', 'temporary']);
     stmCreate.setTableName(rId);
     stmCreate.setAs(createSelectTemplate(dbSeg));
     stmCreate.setPostModifiers(['with no data']);
     return stmCreate;

     function createSelectTemplate(dbSeg) {
     var stm = new sql.Select();

     //SELECT
     stm.addSelects(dbSeg.getQKeyProperties());
     if (dbSeg._ExpandedNavigations.length > 0) {
     stm.addSelects(dbSeg.getNonKeyNonSelectedProperties4Expansion());
     }
     stm.addSelects(dbSeg.getQNonKeyProperties());

     //FROM
     stm.setFrom(dbSeg.getAliasedTableName());
     return stm;
     }*/
}

function masterTableInsertTmp(sqlContext, rId) {
    sqlContext.context.logger.debug('sqlCollector', 'masterTableInsertTmp');
    var dbSeg = sqlContext.dbSegLast;

    var stm = new sql.Insert();
    stm.setTableName({ table: rId });
    //SELECT
    stm.addNames(dbSeg.getQKeyProperties());
    stm.addNames(dbSeg.getQNonKeyProperties());

    //the data is inserted later on
    return stm;

}

function masterTableInsert(sqlContext, rId) {
    sqlContext.context.logger.debug('sqlCollector', 'createPostSQL_Insert_TmpMasterTable');
    var dbSeg = sqlContext.dbSegLast;


    //subselect
    var subSelect = new sql.Select();
    subSelect.addSelects(new sql.Formula(null, '*'));
    subSelect.setFrom({ schema: null, table: rId, alias: null });

    var stm = new sql.Insert();
    //SELECT

    stm.setTableName(dbSeg.getQTableNameNoAlias());
    stm.addNames(dbSeg.getQKeyProperties());
    stm.addNames(dbSeg.getQNonKeyProperties());
    //Values
    stm.setSubSelect(subSelect);
    return stm;
}

/**
 * Create select SQL statement to select from tmp table
 * Since a application exit may be used to do the insert into the real table
 * and possible create a custom key, we can't select with the client-key from the real table
 * so in this case the application has the possiblity to pass the new key back to the client.
 * @param sqlContext
 * @param rId
 * @returns {exports.Select}
 */
function masterTableSelect(sqlContext, rId) {
    sqlContext.context.logger.debug('sqlCollector', 'masterTableSelect');
    var dbSeg = sqlContext.dbSegLast;

    var stmSelect = new sql.Select();

    stmSelect.addSelect(dbSeg.getQKeyPropertiesWith0123AliasForSelect(true));
    stmSelect.addSelects(dbSeg.getPropertiesForSelect(true));
    if (dbSeg._ExpandedNavigations.length > 0) {
        stmSelect.addSelects(dbSeg.getNavPropertiesForSelect(true));
    }

    if (utils.isETagRequired(sqlContext.context, dbSeg)) {
        addETagToSelect(dbSeg, stmSelect, rId);
    }

    stmSelect.setFrom({ schema: null, table: rId, alias: null });
    return stmSelect;
}
