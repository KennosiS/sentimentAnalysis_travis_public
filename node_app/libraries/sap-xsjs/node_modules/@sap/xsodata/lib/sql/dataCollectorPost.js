'use strict';

//Include
var dataCollector = require('./dataCollector');
var sqlStatement = require('./sqlStatement');
var utils = require('../utils/utils');

exports.movePayloadFromSegmentToSelectStm = function (context, asyncDone) {
    context.logger.silly('dataCollectorPost', 'movePayloadFromSegmentToSelectStm');
    //get dbSegment for inserting the payload
    var dbSeg = context.oData.dbSegmentLast;

    var stm = dbSeg.sql.stmContainer.insertTmp;
    if (!stm) {
        return asyncDone("Internal server error", context);
    }

    var max = dbSeg._recordNV.length;
    var i;
    for (i = 0; i < max; i++) {
        var nv = dbSeg._recordNV[i];
        stm.setValue(nv.name, nv.value);
    }
    return asyncDone(null, context);
};


exports.createTmpTable = function (context, asyncDone) {
    context.logger.silly('dataCollectorPost', 'createTmpTable');
    var dbSeg = context.oData.dbSegmentLast;
    var stm = dbSeg.sql.stmContainer.createTmp;
    return dataCollector.execParallelNoResult([stm], context, asyncDone);
};

exports.insertPayloadIntoTempTable = function (context, asyncDone) {
    context.logger.silly('dataCollectorPost', 'insertPayloadIntoTempTable');
    var client = context.db.client;
    var dbSeg = context.oData.dbSegmentLast;
    var stm = dbSeg.sql.stmContainer.insertTmp;

    var p = [];
    var sql = stm.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);
    context.logger.debug('SQL Exec', 'SQL: \n' + sql);
    client.prepare(sql, function (err, statement) {
        if (err) {
            context.logger.info('SQL Exec', 'Error: \n' + err);
            context.logger.info('SQL Exec', 'SQL: \n' + sql);
            return asyncDone(err, context);
        }

        context.logger.debug('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
        statement.exec(p, function (err/*, rows*/) {
            if (err) {
                context.logger.info('SQL Exec', 'Error: \n' + err);
                context.logger.info('SQL Exec', 'SQL: \n' + sql);
                context.logger.info('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                return asyncDone(err, context);
            }

            return asyncDone(null, context);
        });
    });
};

exports.insertTmpTableToRealTable = function (context, asyncDone) {
    context.logger.silly('dataCollectorPost', 'insertToRealTable');
    var client = context.db.client;
    var dbSeg = context.oData.dbSegmentLast;
    var stm = dbSeg.sql.stmContainer.insertReal;

    var p = [];
    var sql = stm.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);
    context.logger.debug('SQL Exec', 'SQL: \n' + sql);
    client.prepare(sql, function (err, statement) {
        if (err) {
            context.logger.info('SQL Exec', 'Error: \n' + err);
            context.logger.info('SQL Exec', 'SQL: \n' + sql);
            return asyncDone(err, context);
        }

        context.logger.debug('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
        statement.exec(p, function (err/*, rows*/) {
            if (err) {
                context.logger.info('SQL Exec', 'Error: \n' + err);
                context.logger.info('SQL Exec', 'SQL: \n' + sql);
                context.logger.info('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                return asyncDone(err, context);
            }
            return asyncDone(null, context);
        });
    });
};

exports.selectData = function (context, asyncDone) {
    context.logger.silly('dataCollectorPost', 'selectData');
    var client = context.db.client;
    var dbSeg = context.oData.dbSegmentLast;
    var stm = dbSeg.sql.stmContainer.select;

    var p = [];

    var sql = stm.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);

    context.logger.debug('SQL Exec', 'SQL: \n' + sql);
    client.prepare(sql, function (err, statement) {
        if (err) {
            context.logger.info('SQL Exec', 'Error: \n' + err);
            context.logger.info('SQL Exec', 'SQL: \n' + sql);
            return asyncDone(err);
        }

        context.logger.debug('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
        statement.exec(p, function (err, rows) {
            if (err) {
                context.logger.info('SQL Exec', 'Error: \n' + err);
                context.logger.info('SQL Exec', 'SQL: \n' + sql);
                context.logger.info('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                return asyncDone(err);
            }
            dbSeg.sql.rows = rows;

            if (rows.length === 1 && utils.isETagHeaderRequired(context, dbSeg)) {
                dbSeg.etagHeader = rows[0].__etag;
            }

            context.logger.silly('selectData', 'rows: ' + JSON.stringify(rows.length));
            context.logger.silly('selectData', 'rows: ' + JSON.stringify(rows, null, 2));

            return asyncDone(null, context);
        });
    });
};


exports.commit = function (context, asyncDone) {
    context.logger.silly('dataCollectorPost', 'commit');
    var client = context.db.client;
    client.commit(function (err) {
        if (err) {
            context.logger.info('SQL Exec', 'Commit Error: \n' + err);
            return asyncDone(err, context);
        }
        return asyncDone(null, context);
    });
};

/**
 * Executes truncation of temporary created tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.truncateTempTables = function (context, asyncDone) {
    var statements;
    context.logger.silly('dataCollectorPost', 'truncateTempTables');

    statements = [context.sql.container.createTmpTruncate];

    return dataCollector.execTempTableStatements(statements, context, asyncDone);
};

/**
 * Executes deletion of temporary created tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.dropTempTables = function (context, asyncDone) {
    var statements;
    context.logger.silly('dataCollectorPost', 'dropTempTables');

    statements = [context.sql.container.createTmpDrop];

    return dataCollector.execTempTableStatements(statements, context, asyncDone);
};



