'use strict';

//Include
var sql = require('./sqlStatement');
var sqlTools = require('./sqlTools');
var utils = require('../utils/utils');

//Code
exports.createPutStatements = function (context, asyncDone) {
    context.logger.silly('sqlCollector', 'createPutStatements');
    var dbSegLast = context.oData.dbSegmentLast;

    var sqlContext = {
        context: context,
        netId: context.uniqueNetworkRequestID,
        reqId: context.uniqueRequestID,
        rId: 1,
        dbSegLast: dbSegLast,
        systemQueryParameters: context.oData.systemQueryParameters
    };
    context.sql = sqlContext;

	// set context.sql.container to be able to use dataCollectorGet to execute SELECT queries
	context.sql.container = dbSegLast.sql.stmContainer = new sql.PutContainer();

    startPutMasterDbSeg(sqlContext);
    return asyncDone(null, context);
};


/**
 * Create SQL statements for the master table (=end of resource path)
 * @param sqlContext
 */
function startPutMasterDbSeg(sqlContext) {
    sqlContext.context.logger.debug('sqlCollector', 'startPutMasterDbSeg');
    var dbSeg = sqlContext.dbSegLast,
	    selectETagStmt,
	    stmtContainer = dbSeg.sql.stmContainer;

    dbSeg.sql.rIdNew = sqlTools.rIdToNewTableName(dbSeg._Alias, sqlContext.netId, sqlContext.reqId,sqlContext.rId++);
    dbSeg.sql.rIdOld = sqlTools.rIdToOldTableName(dbSeg._Alias, sqlContext.netId, sqlContext.reqId,sqlContext.rId++);

    //create statement for master table
	stmtContainer.createTmp = masterTableCreate(sqlContext, dbSeg.sql.rIdNew);

    stmtContainer.createTmpOld = masterTableCreate(sqlContext, dbSeg.sql.rIdOld);

    if (sqlContext.context.db.isExternalHandledConnection === true) {
        // We only truncate and delete temp tables when db connection is handled external
        // otherwise we will self disconnect and temp tables will be deleted automatically

        // build the truncate statement for created temporary table;
        stmtContainer.createTmpTruncate = sql.buildTableStatement(sql.Truncate, sqlContext,
                stmtContainer.createTmp.table);

        stmtContainer.createTmpOldTruncate = sql.buildTableStatement(sql.Truncate, sqlContext,
                stmtContainer.createTmpOld.table);

        // build the drop statement for created temporary table;
        stmtContainer.createTmpDrop = sql.buildTableStatement(sql.Drop, sqlContext,
                stmtContainer.createTmp.table);

        stmtContainer.createTmpOldDrop = sql.buildTableStatement(sql.Drop, sqlContext,
                stmtContainer.createTmpOld.table);
    }

    //create insert statement for master table
	stmtContainer.insertTmp = masterTableInsertToNew(sqlContext, dbSeg.sql.rIdNew);

    //create insert statement for master table
	stmtContainer.insertTmpOld = masterTableInsertToOld(sqlContext, dbSeg.sql.rIdOld);

    //create update statement for master table
	stmtContainer.updateReal = masterTableUpdate(sqlContext,dbSeg.sql.rIdNew);


	// adjust stmtContainer to be able to use dataCollectorGet to execute the SELECT statement for the ETag
	stmtContainer.select = [];
	stmtContainer.selectTmp = [];

	if(utils.isETagRequired(sqlContext.context, dbSeg)) {
		//create select statement to generate ETag for the updated entity
		selectETagStmt = sql.createSelectStmtForETag(dbSeg);
		stmtContainer.select.push({stm: selectETagStmt, dbSeg: dbSeg});
	}
}

function masterTableCreate(sqlContext, rId) {
    sqlContext.context.logger.debug('sqlCollector', 'masterTableCreate');
    var dbSeg = sqlContext.dbSegLast;

    var stmCreate = new sql.Create();
    stmCreate.setModifiers(['local', 'temporary', dbSeg.entityType.tableStoreType]);
    stmCreate.setTableName(rId);
    stmCreate.setAs(createSelectTemplate(dbSeg));
    stmCreate.setPostModifiers(['with no data']);
    return stmCreate;


    /**
     * Create SQL Statement 'Create Master'
     * @param dbSeg
     */
    function createSelectTemplate(dbSeg) {
        var stm = new sql.Select();

        //SELECT
        stm.addSelects(dbSeg.getQKeyProperties());
        if (dbSeg._ExpandedNavigations.length > 0) {
            stm.addSelects(dbSeg.getNonKeyNonSelectedProperties4Expansion());
        }
        stm.addSelects(dbSeg.getQNonKeyProperties());

        //FROM
        stm.setFrom(dbSeg.getAliasedTableName());
        return stm;
    }
}

function masterTableInsertToNew(sqlContext, rId) {
    sqlContext.context.logger.debug('sqlCollector', 'masterTableInsertToNew');
    var dbSeg = sqlContext.dbSegLast;

    var stm = new sql.Insert();
    stm.setTableName({table: rId});
    //SELECT
    stm.addNames(dbSeg.getQKeyProperties());
    stm.addNames(dbSeg.getQNonKeyProperties());

    //the data is inserted later on
    return stm;

}

function masterTableInsertToOld(sqlContext, rId) {
    sqlContext.context.logger.debug('sqlCollector', 'masterTableInsertToNew');
    var dbSeg = sqlContext.dbSegLast;

    var subSelect = new sql.Select();
    subSelect.addSelects(dbSeg.getQKeyPropertiesForSelect());
    subSelect.addSelects(dbSeg.getQNonKeyPropertiesForSelect());
    subSelect.setFrom(dbSeg.getAliasedTableName());
    subSelect.addWhereKeyValuePairs(dbSeg.getQKeyWithValuesDB());

    var stm = new sql.Insert();
    stm.setTableName({table: rId});
    stm.setSubSelect(subSelect);

    return stm;
}

/**
 * Create select SQL statement for master table
 * @param sqlContext
 * @param rId
 * @returns {exports.Select}
 */
function masterTableUpdate(sqlContext, rId) {
    sqlContext.context.logger.debug('sqlCollector', 'masterTableUpdate');
    var dbSeg = sqlContext.dbSegLast;

    var update = new sql.Update();
    update.setTable(dbSeg.getAliasedTableName('PERM')); //overwrite alias

    //update.addSetCopyProperties(dbSeg.getQKeyProperties(), 'TEMP');
    update.addSetCopyProperties(dbSeg.getQNonKeyProperties(), 'TEMP');

    update.setFrom({
        table: rId,
        alias: 'TEMP'
    });
    update.addWhereKeyValuePairs(dbSeg.getQKeyWithValues('PERM'));

    return update;
}
