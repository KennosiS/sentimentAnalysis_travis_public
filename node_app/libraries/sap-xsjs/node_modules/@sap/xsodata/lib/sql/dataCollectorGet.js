'use strict';

//Include
var async = require('async');
var dataCollector = require('./dataCollector');
var sqlStatement = require('./sqlStatement');
var utils = require('../utils/utils');

exports.createTmpTables = function (context, asyncDone) {
    context.logger.silly('dataCollectorGet', 'createTmpTables');
    var container = context.sql.container;
    var stms = [];
    var i;

    for (i = 0; i < container.createTmp.length; i++) {
        stms.push(container.createTmp[i].stm);
    }
    return dataCollector.execParallelNoResult(stms, context, asyncDone);

};


exports.insertFillTmpTables = function (context, asyncDone) {
    context.logger.silly('dataCollectorGet', 'insertFillTmpTables');
    var client = context.db.client;

    var container = context.sql.container;
    var stms = container.insertTmp;

    async.mapSeries(stms,
        function (item, cb) {
            try {
                var p = [];
                var sql = item.stm.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);
                context.logger.debug('SQL Exec', 'SQL: \n' + sql);
                client.prepare(sql, function (err, statement) {
                    if (err) {
                        context.logger.info('SQL Exec', 'Error: \n' + err);
                        context.logger.info('SQL Exec', 'SQL: \n' + sql);
                        return cb(err);
                    }

                    context.logger.debug('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                    statement.execute(p, function (err/*, rows*/) {
                        if (err) {
                            context.logger.info('SQL Exec', 'Error: \n' + err);
                            context.logger.info('SQL Exec', 'SQL: \n' + sql);
                            context.logger.info('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                            return cb(err);
                        }
                        cb();
                    });
                });
            } catch (ex) {
                cb(ex);
            }
        }, function (err/*, results*/) {
            if (err) {
                return asyncDone(err, context);
            }
            return asyncDone(null, context);
        }
    );
};


exports.select = function (context, asyncDone) {
    context.logger.silly('dataCollectorGet', 'selectData');
    var client = context.db.client;

    var container = context.sql.container;

    var stms = container.select.concat(container.selectTmp);

    async.mapSeries(stms,
        function (item, cb) {
            try {
                execStatement(item, function (err, rows) {
                    if (err) {
                        return cb(err);
                    }

                    if (rows.length === 0 && item.stm.getFallbackStatement && item.stm.getFallbackStatement()) {
                        return execStatement({
                            stm: item.stm.getFallbackStatement(),
                            dbSeg: item.dbSeg
                        }, cb, true);
                    }

                    return cb(null, rows);
                });
            } catch (ex) {
                cb(ex);
            }
        }, function (err) {
            if (err) {
                return asyncDone(err, context);
            }
            return asyncDone(err, context);
        }
    );

    function execStatement(item, cb, count) {
        var p = [];

        context.logger.debug('dataCollector', 'count fallback: ' + !!count);
        context.logger.silly('dataCollector', 'pre to hana');
        var sql = item.stm.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);

        context.logger.debug('SQL Exec', 'SQL: \n' + sql);
        client.prepare(sql, function (err, statement) {
            if (err) {
                context.logger.info('SQL Exec', 'Error: \n' + err);
                context.logger.info('SQL Exec', 'SQL: \n' + sql);
                return cb(err);
            }

            context.logger.debug('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
            statement.exec(p, function (err, rows) {
                if (err) {
                    context.logger.info('SQL Exec', 'Error: \n' + err);
                    context.logger.info('SQL Exec', 'SQL: \n' + sql);
                    context.logger.info('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                    return cb(err);
                }

                if (!count) {
                    item.dbSeg.sql.rows = rows;
                    item.dbSeg.sql.countRows = [];

                    if (rows.length === 1 && utils.isETagHeaderRequired(context, item.dbSeg)) {
                        item.dbSeg.etagHeader = rows[0].__etag;
                    }
                } else {
                    item.dbSeg.sql.rows = [];
                    item.dbSeg.sql.countRows = rows;
                }

                context.logger.silly('dataCollector', JSON.stringify(rows.length));
                context.logger.silly('dataCollector', JSON.stringify(rows, null, 2));
                cb(null, rows);
            });
        });
    }
};

/**
 * Executes SQL SELECT statement.
 *
 * @param {Object} context - OData context
 * @param {Object} selectStmt - instance of Select "class" from sqlStatement.js
 * @param {Function} callback - callback, which should be called once the operation is completed
 */
exports.executeSelect = function executeSelect(context, selectStmt, callback) {
    var client = context.db.client,
        parameters = [],
        sql;

    try {
        sql = selectStmt.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), parameters);
    } catch (e) {
        return callback(e);
    }

    context.logger.debug('executeSelect', 'SQL: \n' + sql);
    client.prepare(sql, function (err, statement) {
        if (err) {
            context.logger.info('executeSelect', 'Error: \n' + err);
            context.logger.info('executeSelect', 'SQL: \n' + sql);
            return callback(err);
        }

        context.logger.debug('executeSelect', 'Parameters:\n' + JSON.stringify(parameters));
        statement.exec(parameters, function (err, rows) {
            if (err) {
                context.logger.info('executeSelect', 'Error: \n' + err);
                context.logger.info('executeSelect', 'SQL: \n' + sql);
                context.logger.info('executeSelect', 'Parameters:\n' + JSON.stringify(parameters));
                return callback(err);
            }

            callback(null, rows);
        });
    });
};

/**
 * Executes truncation of temporary created tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.truncateTempTables = function (context, asyncDone) {
    context.logger.silly('dataCollectorGet', 'truncateTempTables');
    return dataCollector.execTempTableStatements(context.sql.cleanSessionTruncateContainer, context, asyncDone);
};

/**
 * Executes deletion of temporary created tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.dropTempTables = function (context, asyncDone) {
    context.logger.silly('dataCollectorGet', 'dropTempTables');
    return dataCollector.execTempTableStatements(context.sql.cleanSessionDropContainer, context, asyncDone);
};
