'use strict';

var async = require('async');
var RequestContext = require('./../requestContext');
var uriProcessor = require('./../../http/uriParser');
var xsodataFileReader = require('./../../model/xsodataReader');
var metadataDbReader = require('./../../model/metadataReader');
var oDataUriParser = require('./../../uri/oDataUriParser');
var oDataProcessor = require('./../../processor/processor');
var errorProcessor = require('./../../processor/errorProcessor');
var TestError = require('./../errors/testError');
var DebugInfo = require('./../errors/debugInfo');
var applyUriChecks = require('./../../uri/applyChecks');
var uriChecks = require('./../../uri/checks');
var batchConst = require('./batchConst');
var configuration = require('./../../configuration');
var json = require('./../../serializer/jsonSerializer');
var utils = require('./../utils');
var ConditionalHttpHandler = require('./../../http/conditionalHttpHandler');


exports.processPrePostCommitRun = function (request, response, batchContext, context, done) {
    context.logger.silly('batchProcessor', 'processApp');
    try {
        async.waterfall(
            [
                utils.injectContext(context),
                utils.try(oDataProcessor.processRequest)
            ], function (err/*, contextFinish*/) {
                if (err) {
                    if (context.mode === configuration.modes.development) {
                        if (err instanceof TestError) {
                            context.logger.debug('xsodata', 'dev mode: is TestError');
                            return (done ? done(err, context) : null);
                        }
                    }
                    if (err instanceof DebugInfo) {
                        var serializer = new json.JsonSerializer(context, 65536, 200);
                        serializer.write(err.message);
                        serializer.flush();
                    } else {
                        errorProcessor.process(context, err);
                    }

                    if (batchContext.inChangeSet) {
                        err._changeSetErrorResponse = response;
                    }

                    finish(err, context, done);


                    return;
                }

                finish(null, context, done);

            }
        );
    } catch (exception) {
        context.logger.info('xsodata', 'process-exception: ' + JSON.stringify(exception));
        if (done) {
            done(exception);
        } else {
            throw exception;
        }
    }
};

function fillContentID(context, asyncDone) {
    var batchContext = context.batchContext;
    var app = context.app;
    if (batchContext.inChangeSet) {

        if (app.contentId) {
            context.logger.silly('batchExecutor', 'set contentID ' + app.contentId.id + ' = ' + context.contendId);
            app.contentId.value = context.contentId;
        }
    }
    return asyncDone(null, context);
}

function checkUriForContentIDs(context, asyncDone) {
    context.logger.silly('batchExecutor', 'check uri for contentID');

    var uri = context.request.url;
    var batchContext = context.batchContext;
    if (!batchContext.inChangeSet) {
        return asyncDone(null, context);
    }
    var part = batchContext.processedPart;
    var contentIds = part.contentIds.list;

    var id;
    for (var i = 0; i < contentIds.length; i++) {
        id = '$' + contentIds[i].id;
        if (uri.indexOf(id) > -1) {
            uri = uri.replace(id, contentIds[i].value);
        }
    }//TODO add check if not all $ are replaced

    context.request.urlOrig = context.request.url;
    context.request.url = uri;

    return asyncDone(null, context);
}


exports.processCreateTables = function (app, request, response, batchContext, done) {
    batchContext.parentContext.logger.silly(
        'batchExecutor', 'process step: ' + batchContext.status + ' ' + batchConst.runStateText[batchContext.status]
    );

    var context = new RequestContext(
        batchContext.parentContext.networkContext,
        batchContext.parentContext.networkContext.requestOptions
    );

    app.context = context;
    context.app = app;
    context.db = batchContext.parentContext.db;
    context.logger.silly('xsodata', 'process batch: ' + request.url);

    context.batchContext = batchContext;

    //set req,res,db data
    context.request = request;
    context.response = response;

    //inject model into context
    context.modelData = batchContext.parentContext.modelData;

    try {
        async.waterfall(
            [
                utils.injectContext(context),
                utils.try(checkUriForContentIDs),

                utils.try(uriProcessor.prepareUri),
                utils.try(xsodataFileReader.loadXsodataConfiguration),
                utils.try(metadataDbReader.loadModelMetadata),
                utils.try(oDataUriParser.parseODataUri),
                utils.try(applyUriChecks.bind(null, uriChecks)),
                utils.try(oDataProcessor.processRequest),
                utils.try(fillContentID)
                //utils.try(fillContentID.bind(null, app))
            ], function (err) {

                if (err) {

                    if (context.mode === configuration.modes.development) {
                        if (err instanceof TestError) {
                            context.logger.debug('xsodata', 'dev mode: is TestError');
                            return (done ? done(err, context) : null);
                        }
                    }
                    if (err instanceof DebugInfo) {
                        var serializer = new json.JsonSerializer(context, 65536, 200);
                        serializer.write(err.message);
                        serializer.flush();
                    } else {
                        errorProcessor.process(context, err);
                    }

                    if (batchContext.inChangeSet) {
                        err._changeSetErrorResponse = app.response;
                    }

                    // this request has and error and the response is already written, so don't process further step in
                    // the processing chain.
                    app.errorResponseWritten = true;
                    return finish(err, context, done);
                }

                return finish(null, context, done);

            }
        );
    } catch (exception) {
        context.logger.info('xsodata', 'process-exception: ' + JSON.stringify(exception));
        if (done) {
            done(exception);
        } else {
            throw exception;
        }
    }
};

exports.process = function (request, response, batchContext, context, done) {
    context.logger.silly('batchExecutor', 'process step: ' + batchContext.status  + ' ' + batchConst.runStateText[batchContext.status]);

    var app = context.app;

    try {
        async.waterfall(
            [
                utils.injectContext(context),
                //utils.try(checkUriForContentIDs),
                //utils.try(uriProcessor.prepareUri),
                //utils.try(xsodataFileReader.readFile),
                //utils.try(metadataDbReader.getMetadataReader(context.handlerConfiguration).loadModelMetadata),
                //utils.try(oDataUriParser.parseODataUri),
                //utils.try(applyUriChecks.bind(null, uriChecks)),
                utils.try(ConditionalHttpHandler.processConditionalRequest),
                utils.try(oDataProcessor.processRequest)

            ], function (err) {

                if (err) {
                    if (context.mode === configuration.modes.development) {
                        if (err instanceof TestError) {
                            context.logger.debug('xsodata', 'dev mode: is TestError');
                            return (done ? done(err, context) : null);
                        }
                    }
                    if (err instanceof DebugInfo) {
                        var serializer = new json.JsonSerializer(context, 65536, 200);
                        serializer.write(err.message);
                        serializer.flush();
                    } else {
                        errorProcessor.process(context, err);
                    }

                    if (batchContext.inChangeSet) {
                        err._changeSetErrorResponse = app.response;
                    }

                    return finish(err, context, done);
                }

                return finish(null, context, done);

            }
        );
    } catch (exception) {
        context.logger.info('xsodata', 'process-exception: ' + JSON.stringify(exception));
        if (done) {
            done(exception);
        } else {
            throw exception;
        }
    }
};

function finish(err, context, done) {
    context.logger.info('xsodata', 'finish');
    context.response.end();
    if (done) {
        return done(err, context);
    }
}
