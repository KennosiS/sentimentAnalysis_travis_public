'use strict';

var _ = require('lodash');
var getCollector = require('../sql/dataCollectorGet');

var sqlStatement = require('./../sql/sqlStatement');
var dbConnect = require('./../db/connect');

var nodeUtils = require('util');
var xsODataUtils = require('../utils/utils');

var typedObjects = require('./../utils/typedObjects');
var EntityType = require('../model/entityType.js');

var typeConverter = require('./../utils/typeConverter');

var keyGenerator = require('../utils/keyGenerator');

var InternalError = require('../utils/errors/internalError');
var BadRequest = require('../utils/errors/http/badRequest');
//var NotSupported = require('../utils/errors/http/notSupported');


// Types of db segments
exports.DBS_Entity = 2;
exports.DBS_ResourceNavigation = 3;
exports.DBS_Property = 4;
exports.DBS_Navigation = 6; // expanded navigation || selected navigation

exports.DbSegment = DbSegment;

/**
 * Constructs a dbSegment. A dbSegment stores all information to load data from one actual database table
 *
 * @param kind  Either Entity, Navigation in resource path, property or navigation in expand tree
 * @param entityType
 * @param nr    Id used for creating temporary table with unique names
 * @constructor
 */
function DbSegment(kind, entityType, nr) {
    this.kind = kind;
    this.previousDBSegment = null;

    this.entityType = entityType;

    // restrictions used on last segment of resource path
    this.restriction = {
        onlyCount: false, // $count used in uri
        onlyRefs: false,  // $ref used in uri
        onlyValue: false  // $value used in uri
    };

    this.isLinks = false;
    this.isCollection = undefined;
    this.singleProperty = null;

    this._end = {from: null, to: null};


    //for SQL generation
    this._DB_Schema = entityType.schema;
    this._DB_TableName = entityType.tableName;
    this._AliasName = entityType.name;
    this._AliasId = nr;
    this._Alias = this._AliasName + this._AliasId;

    /**
     * List of key predicates
     * @type {Array<{Key : string,Value : string}>}
     * @private
     */
    this._KeyValues = [];
    this._ParameterValues = [];
    this._recordNV = [];
    /*use for post/put/delete*/
    this._recordMap = {};

    /**
     * Input parameters if this dbSegment queries a calcview
     * @type {Array<{Key : string,Value : string}>}
     * @private
     */
    this._InputParams = [];

    /**
     * Selected property name (either by * all properties of the entity set or explicit via $select)
     * @type {Array<String>}
     */
    this._SelectedProperties = [];
    /**
     * Store column names ordered
     * @type {Array<String>}
     */
    this._SelectedPropertiesOrdered = null;
    /**
     * Store names existing of navigation properties
     * @type {Array<String>}
     */
    this._SelectedNavigations = [];      //Array of string
    /**
     * Store names of really expanded of navigation properties
     * @type {Array<String>}
     */
    this._ExpandedNavigations = [];      //Array of string
    /**
     * Store dbSegments of really expanded of navigation properties
     * @type {Map<String,DbSegment>}
     */
    this._ExpandedNavigationsDBSeg = {}; //Array of DbSegments
    /**
     * Store dbSegments of used navigation properties. May contain more navigation properties than
     * attribute _ExpandedNavigationsDBSeg
     * @type {Map<String,DbSegment>}
     */
    this._relevantNavigationSegments = {};

    this.isGenKeySelected = false;

    this.systemQueryParameter = {
        filter: null,
        orderBy: null,
        top: null,
        skip: null
    };

    this.sql = {
        stmContainer: null,
        rows: null,
        rowsInput: null,
        readPosition: 0
    };

    /**
     *
     * @type {null}
     */
    this._rowsWithGenKey = null;

    this.nextDBSegment = null;

    this.association = null;
}

/**
 * Return only the alias for the table
 * @returns {string} Alias used to reference the table
 */
DbSegment.prototype.getAlias = function () {
    return this._Alias;
};

/**
 * Return only the alias for an association
 * @returns {string} Alias used to reference the association
 */
DbSegment.prototype.getAssocAlias = function () {
    return 'Assoc' + this._AliasId;
};

/**
 * Returns the tableName with schema and alias
 * @returns {{schema: string, table: string, alias: string}}
 */
DbSegment.prototype.getAliasedTableName = function (alias) {
    return {
        schema: this._DB_Schema,
        table: this._DB_TableName,
        alias: alias || this._Alias
    };
};

/**
 * Check if the given dbSegment navigates the corresponding association from its principal end
 * @returns {boolean}
 * */
DbSegment.prototype.isPrincipal = function () {
    if (this.entityType.name === this.association.principal.type) {
        return true;
    }
    return false;
};

/**
 * Uses properties from record and add them to the _recordMap and _recordNV attributes.
 *
 *
 * @param context
 * @param record
 */
DbSegment.prototype.setRecordPOST = function (context, record) {
    var converterArray = typeConverter.converterFunctions.jsonPayloadToDbName;
    var value;
    var dbValue;
    var dbType;
    var i;
    var converter;

    var supportNullable = context.gModel.isNullSupported();
    var isNullable;

    //Loop through the properties of the entityType.
    Object.keys(this.entityType.propertiesMap).forEach(function (property) {
        //Load property from record
        value = record[property];


        if (value === undefined) {
            // Use columns default value
            dbValue = this.entityType.propertiesMap[property]['DEFAULT_VALUE'];
        } else if (value === null) {
            // Use null
            isNullable = this.entityType.propertiesMap[property]['IS_NULLABLE'] === 'TRUE';
            if (!supportNullable || !isNullable) {
                throw new BadRequest('The serialized resource has an missing value for member ' + property);
            }
            dbValue = null;
        } else {
            //Use the converted value
            dbType = this.entityType.propertiesMap[property]['DATA_TYPE_NAME'];
            converter = converterArray[typeConverter.dbTypeNameToODataTypeName[dbType]];

            dbValue = converter(value, dbType);
        }

        this._recordMap[property] = dbValue;
        this._recordNV.push({name: property, value: dbValue});
    }.bind(this));

    //set KeyValues
    var max = this.entityType.keys.names.length;
    for (i = 0; i < max; i++) {
        this._KeyValues.push(
            {
                name: this.entityType.keys.names[i],
                value: this._recordMap[this.entityType.keys.names[i]]
            }
        );
    }

    //Check that no additional properties (and also no inline content) are send to server
    /*Object.keys(record).forEach(function (property) {
        if (!this.entityType.propertiesMap[property]) {
            if (!this.entityType.navPropertiesMap[property]) {
                throw new BadRequest('Property "' + property + '" unknown.');
            } else {
                throw new NotSupported('POST with inlined content "' + property + '" not supported.');
            }

        }
    }.bind(this));*/
};


DbSegment.prototype.getKey = function (key) {
    for (var i = 0; i < this._KeyValues.length; i++) {
        if (this._KeyValues[i].name === key) {
            return this._KeyValues[i];
        }
    }
    return undefined;
};

DbSegment.prototype.hasKeyValues = function () {
    return this._KeyValues.length > 0;
};


DbSegment.prototype.setRecordPUT = function (context, record) {
    var supportNullable = context.gModel.isNullSupported();
    var isNullable;
    var converterArray = typeConverter.converterFunctions.jsonPayloadToDbName;
    var value;
    var dbValue;
    var dbType;


    //Check if all required properties are send to server
    Object.keys(this.entityType.propertiesMap).forEach(function (property) {
        var kv = this.getKey(property);
        if (kv) {
            dbValue = kv.value;
            this._recordMap[property] = dbValue;
            this._recordNV.push({name: property, value: dbValue});
        } else {
            value = record[property];
            dbValue = null;
            dbType = this.entityType.propertiesMap[property]['DATA_TYPE_NAME'];
            isNullable = this.entityType.propertiesMap[property]['IS_NULLABLE'] === 'TRUE';
            if (value === undefined) {
                if (supportNullable && isNullable) {
                    dbValue = null;
                } else {
                    throw new BadRequest('The serialized resource has an missing value for member ' + property);
                }
            } else {
                dbValue = converterArray[typeConverter.dbTypeNameToODataTypeName[dbType]](value, dbType);
            }

            this._recordMap[property] = dbValue;
            this._recordNV.push({name: property, value: dbValue});
        }
    }.bind(this));

    //Check that no additional properties (and also no inline content) are send to server
    /*Object.keys(record).forEach(function (property) {
        if (!this.entityType.propertiesMap[property]) {
            if (!this.entityType.navPropertiesMap[property]) {
                throw new BadRequest('Property "' + property + '" unknown.');
            } else {
                throw new NotSupported('PUT with inlined content "' + property + '" not supported.');
            }
        }
    }.bind(this));*/
};

DbSegment.setRecordPutPostLinks = function (context) {
    var toBeUpdated = context.oData.links.toBeUpdated;
    var keySource = context.oData.links.keySource;

    // Add keys
    toBeUpdated._KeyValues.forEach(function (key) {
        toBeUpdated._recordMap[key.name] = key.value;
        toBeUpdated._recordNV.push({name: key.name, value: key.value});
    });

    // Add foreign keys, e.g. Employees.ManagerId
    var fkeys = toBeUpdated.getQForeignKeyProperties();
    fkeys.forEach(function (key, i) {
        var name = key.property;
        var val = keySource._KeyValues[i].value;
        toBeUpdated._recordMap[name] = val;
        toBeUpdated._recordNV.push({name: name, value: val});
    });
};

DbSegment.setRecordDeleteLinks = function (context) {
    var toBeUpdated = context.oData.links.toBeUpdated;

    // Add keys
    toBeUpdated._KeyValues.forEach(function (key) {
        toBeUpdated._recordMap[key.name] = key.value;
        toBeUpdated._recordNV.push({name: key.name, value: key.value});
    });
    // Skip adding foreign keys, so that later in movePayloadFromSegmentToSelectStm they are set to 'null'
};

/**
 * Returns the tableName with schema and alias
 * @returns {{schema: string, table: string}}
 */
DbSegment.prototype.getQTableNameNoAlias = function () {
    return {
        schema: this._DB_Schema,
        table: this._DB_TableName
    };
};
/**
 * @returns {{type: string, joinProperties: [string], multiplicity: string}}
 */
DbSegment.prototype.getTo = function () {
    return this._end.to;
};

/**
 * @param {{type: string, joinProperties: [string], multiplicity: string}} endTo
 */
DbSegment.prototype.setTo = function (endTo) {
    this._end.to = endTo;
};


/**
 * @param {{type: string, joinpProperties: [string], multiplicity: string}} endFrom
 */
DbSegment.prototype.setFrom = function (endFrom) {
    this._end.from = endFrom;
};
/**
 * @returns {{type: string, joinProperties: [string], multiplicity: string}}
 */
DbSegment.prototype.getFrom = function () {
    return this._end.from;
};

DbSegment.prototype.setOver = function (endOver) {
    this._end.over = endOver;
};

DbSegment.prototype.getOver = function () {
    return this._end.over;
};

DbSegment.prototype.setLinks = function () {
    if (this.previousDBSegment) {
        this.previousDBSegment.setLinks();
    } else {
        this.isLinks = true;
    }
};

/**
 * Returns the key names as TableColumn array for usage in the INSERT, UPDATE or CREATE TABLE SQL statements.
 * @returns {sql.TableColumn[]}
 */
DbSegment.prototype.getQKeyProperties = function () {
    var ret = [];

    for (var i = 0; i < this.entityType.keys.names.length; i++) {
        ret.push(new sqlStatement.TableColumn(this._Alias, this.entityType.keys.names[i]));
    }
    return ret;
};

/**
 * Returns the key names as SelectProperty array for usage in a SELECT SQL statement.
 * @returns {sqlStatement.SelectProperty[]}
 */
DbSegment.prototype.getQKeyPropertiesForSelect = function () {
    return this._createSelectProperties(this._Alias, this.entityType.keys.names);
};

/**
 * Creates an array of SelectProperty instances for usage in a SELECT SQL statement.
 * @returns {sqlStatement.SelectProperty[]}
 */
DbSegment.prototype._createSelectProperties = function (tableAlias, propertyNames, with0123Alias) {
    var propertiesMap = this.entityType.propertiesMap;

    return propertyNames.map(function (propertyName, index) {
        var property = propertiesMap[propertyName],
            propertyType = property.aggregate ? null : property.DATA_TYPE_NAME;

        return new sqlStatement.SelectProperty(tableAlias, propertyName, propertyType,
            with0123Alias ? index.toString() : undefined);
    });
};

DbSegment.prototype.getQKeyPropertiesWith0123AliasForSelect = function (noTable) {
    return this._createSelectProperties(noTable ? null : this._Alias, this.entityType.keys.names, true);
};

DbSegment.prototype.getKeyProperties0123ForSelect = function (noTable) {
    var ret = [];


    var keyNames = this.entityType.keyNamesOrdered;

    for (var i = 0; i < keyNames.length; i++) {
        ret.push(
            new sqlStatement.SelectProperty(noTable ? null : this._Alias, i.toString(), null)
        );
    }
    return ret;
};

DbSegment.prototype.prepareInputParameters = function (context) {
    context.logger.silly('dbsegment', 'prepareInputParameters');

    var etInParams = [];
    this.entityType.properties.forEach(function (property) {
        if (property.KIND === EntityType.entityKind.inputParameters) {
            etInParams.push(property);
        }
    });
    etInParams.forEach(function (etInParam) {
        var param = _.find(this._KeyValues, function (kv) {
            return kv.name === etInParam.COLUMN_NAME;
        });
        if (param) {
            context.logger.silly('dbsegment', 'name: ' + param.name + '(' + typeConverter.dbTypeNameToODataTypeName[etInParam.DATA_TYPE_NAME] + ')');

            this._InputParams.push({key: param.name, value: param.value});
        }
    }, this);
};

/**
 * Adds a table input parameter when accessing a calcview with localVariables.
 * E.g. OrderValues.hdbcalculationview with IP_LANG and IP_CLIENT
 * Call via: http://.../material.xsodata/OrderValueParameters(IP_CLIENT='100',IP_LANG='E')/Results?$format=json
 *
 * @param context
 * @param key
 * @param value
 */
DbSegment.prototype.addInputParameter = function (context, key, value) {
    context.logger.silly('dbsegment', 'addInputParameter');
    context.logger.silly('dbsegment', 'name: ' + key + '(' + typeConverter.dbTypeNameToODataTypeName[this.entityType.inputParameters[key].COLUMN_TYPE_D] + ')');
    this._InputParams.push({key: key, value: value});
};

DbSegment.prototype.getInputParameters = function () {
    return this._InputParams;
};

DbSegment.prototype.getParameterValue = function (parameterName) {
    var param = _.find(this._InputParams, function (kv) {
        return kv.key === parameterName;
    });
    if (param) {
        return param.value;
    }
    /*
     if(!param){
     param = _.find(this._KeyValues, function(kv){return kv.name===parameterName});
     return param.value.string;
     }else{
     return param.value;
     }*/
};

DbSegment.prototype.getKeyProperties0123ForSelectAs0123 = function (noTable) {
    var ret = [],
        keyNames,
        keyName,
        property,
        selectProperty,
        propertyType,
        paramValue,
        i;

    keyNames = this.entityType.keyNamesOrdered;

    for (i = 0; i < keyNames.length; i++) {
        keyName = keyNames[i];
        property = this.entityType.propertiesMap[keyName];
        selectProperty = null;

        if (property.KIND === EntityType.entityKind.inputParameters) {
            paramValue = this.getParameterValue(property.COLUMN_NAME);
            selectProperty = new sqlStatement.ParameterSelectProperty(noTable ? null : this._Alias, keyName, i.toString(), paramValue);
        } else {
            propertyType = property.aggregate ? null : property.DATA_TYPE_NAME;
            selectProperty = new sqlStatement.SelectProperty(noTable ? null : this._Alias, keyName, propertyType, i.toString());
        }

        ret.push(selectProperty);
    }
    return ret;
};

/**
 * Returns a selectProperty for usage in the select part of sql statements
 * The property are named "0","1","2",... and have as type the type of the corresponding key ( ordered by position
 * @returns {sqlStatement.SelectProperty[]}
 */
DbSegment.prototype.getKeyProperties0123ForCreate = function () {
    var ret = [];


    var keyNames = this.entityType.keyNamesOrdered;
    var propertiesMap = this.entityType.propertiesMap;

    for (var i = 0; i < keyNames.length; i++) {
        var keyName = keyNames[i];
        var property = propertiesMap[keyName];
        var typeString = property.DATA_TYPE_NAME;

        if (typeString === 'DECIMAL') {
            typeString += '(' + property.LENGTH.toString() + ',' + property.SCALE.toString() + ')';
        } else if (typeString === 'VARCHAR') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'NVARCHAR') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'ALPHANUM') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'CHAR') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'NCHAR') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'VARBINARY') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'SHORTTEXT') {
            typeString = 'NVARCHAR(10)';
        }

        ret.push(
            new sqlStatement.CreateProperty(i.toString(), typeString)
        );
    }
    return ret;
};

DbSegment.prototype.getKeyProperties0123ForOrderBy = function (noTable) {
    var ret = [];

    var keyNames = this.entityType.keyNamesOrdered;

    for (var i = 0; i < keyNames.length; i++) {
        ret.push(
            new typedObjects.SortOrder(new typedObjects.Property(i.toString(), noTable ? null : this._Alias), 'ASC')
        );
    }
    return ret;
};

DbSegment.prototype.getKeyPropertiesNotSelectedForSelect = function (noTable) {
    var ret = [],
        keyNames,
        i,
        keyName,
        key,
        propertyType;

    keyNames = this.entityType.keyNamesOrdered;

    for (i = 0; i < keyNames.length; i++) {
        keyName = keyNames[i];
        key = this.entityType.propertiesMap[keyName];

        if ((this._getSortedSelectProperties().indexOf(keyName) === -1 ) &&
            (this._SelectedNavigations.indexOf(keyName) === -1 )) {
            propertyType = key.aggregate ? null : key.DATA_TYPE_NAME;
            ret.push(new sqlStatement.SelectProperty(noTable ? null : this._Alias, keyName, propertyType, null));
        }
    }
    return ret;
};

DbSegment.prototype.getKeyPropertiesNotSelectedForCreate = function () {
    var ret = [];

    var keyNames = this.entityType.keyNamesOrdered;
    var propertiesMap = this.entityType.propertiesMap;


    for (var i = 0; i < keyNames.length; i++) {
        var keyName = keyNames[i];
        if ((this._getSortedSelectProperties().indexOf(keyName) === -1 ) && (this._SelectedNavigations.indexOf(keyName) === -1 )) {
            var property = propertiesMap[keyName];
            var typeString = createPropertyTypeString(property);

            ret.push(
                new sqlStatement.CreateProperty(keyName, typeString)
            );
        }
    }
    return ret;
};

DbSegment.prototype.getPropertiesForCreate = function () {
    var ret = [];

    //var properties = this.entityType.properties;
    var properties = this._getSortedSelectProperties();
    for (var i = 0; i < properties.length; i++) {
        var property = this.entityType.propertiesMap[properties[i]];

        ret.push(
            createSqlCreateProperty(property)
        );
    }
    return ret;
};

// Get the properties (as full objects, e.g. with data type etc.) of the associative entity (3rd table)
// via the association's 'over', for CREATE statements
DbSegment.prototype.getOverPropertiesForCreate = function () {
    var ret = [];
    var over = this.getOver();
    // fetch Key property from original table
    var keyProp1 = this.previousDBSegment.entityType.propertiesMap[this.getFrom().joinproperties[0]];
    // update the column and table name according to the associative table
    keyProp1.COLUMN_NAME = over.principal[0];
    keyProp1.TABLE_NAME = over.object;
    var keyProp2 = this.entityType.propertiesMap[this.getTo().joinproperties[0]];
    keyProp2.COLUMN_NAME = over.dependent[0];
    keyProp2.TABLE_NAME = over.object;

    var properties = [keyProp1, keyProp2];
    for (var i = 0; i < properties.length; i++) {
        ret.push(
            createSqlCreateProperty(properties[i])
        );
    }
    return ret;
};

function createSqlCreateProperty(property) {
    return new sqlStatement.CreateProperty(property.COLUMN_NAME, createPropertyTypeString(property));
}

function createPropertyTypeString(property) {
    var typeString = property.DATA_TYPE_NAME;

    if (typeString === 'DECIMAL') {
        typeString += '(' + property.LENGTH.toString() + ',' + property.SCALE.toString() + ')';
    } else if (typeString === 'VARCHAR') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'NVARCHAR') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'ALPHANUM') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'CHAR') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'NCHAR') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'VARBINARY') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'SHORTTEXT') {
        typeString = 'NVARCHAR(10)';
    }

    return typeString;
}


DbSegment.prototype.getPropertiesForSelect = function (noTable) {
    var ret = [],
        properties = this._getSortedSelectProperties(),
        property,
        selectProperty,
        propertyType;

    for (var i = 0; i < properties.length; i++) {
        property = this.entityType.propertiesMap[properties[i]];
        selectProperty = null;

        if (property.KIND === EntityType.entityKind.inputParameters) {
            var paramValue = this.getParameterValue(property.COLUMN_NAME);
            selectProperty = new sqlStatement.ParameterSelectProperty(noTable ? null : this._Alias, properties[i], null, paramValue);
        } else {
            propertyType = property.aggregate ? null : property.DATA_TYPE_NAME;
            selectProperty = new sqlStatement.SelectProperty(noTable ? null : this._Alias, properties[i], propertyType, null);
        }

        ret.push(selectProperty);
    }
    return ret;
};

// Get the properties (as names only) of the associative entity (3rd table) via the association's 'over', for SELECT statements
DbSegment.prototype.getOverPropertiesForSelect = function (rId) {
    var ret = [], selectProperty;

    var over = this.getOver();
    var keyProp1 = over.principal[0];
    var keyProp2 = over.dependent[0];

    var properties = [keyProp1, keyProp2];
    for (var i = 0; i < properties.length; i++) {
        selectProperty = new sqlStatement.SelectProperty(rId, properties[i], null);
        ret.push(
            selectProperty
        );
    }
    return ret;
};

DbSegment.prototype.getAllSelectedPropertiesConsideringAggregates = function (noTable) {
    var table = noTable ? null : this._Alias;
    var withAlias = true;
    return this._getSortedSelectProperties().map(createSelectProperty.bind(this, table, withAlias));
};

DbSegment.prototype.getPropertyAsSelectProperty = function (propertyName) {
    var withAlias = false;
    return createSelectProperty.call(this, this._Alias, withAlias, propertyName);
};

function createSelectProperty(table, withAlias, propertyName) {
    /* jshint -W040 */
    var aggregate,
        alias,
        property,
        propertyType;

    aggregate = this.entityType.getAggregates().filter(function (aggregate) {
        return propertyName === aggregate.column;
    }).shift();


    if (aggregate) {
        alias = withAlias && propertyName;
        return new sqlStatement.AggregateSelectProperty(aggregate.function.toLowerCase(), table, propertyName, alias);
    }

    property = this.entityType.propertiesMap[propertyName];
    if (property.KIND === EntityType.entityKind.inputParameters) {
        return new sqlStatement.ParameterSelectProperty(table, propertyName, null, this.getKey(propertyName));
    }

    propertyType = property.aggregate ? null : property.DATA_TYPE_NAME;
    return new sqlStatement.SelectProperty(table, propertyName, propertyType, null);
    /* jshint +W040 */
}

DbSegment.prototype.getNonKeyJoinProperties = function () {
    var keys = this.entityType.keyNamesOrdered;
    var joinProperties = this.getTo() && this.getTo().joinproperties || [];
    var joinProps = joinProperties.filter(function (joinProp) {
        return keys.indexOf(joinProp) < 0;
    });

    return concatJoinProperties([], joinProps, this._Alias);
};

DbSegment.prototype.getAllSelectedIncludingJoinPropertiesConsideringAggregates = function (noTable) {
    var table = noTable ? null : this._Alias;
    var selectedProperties = this.getAllSelectedPropertiesConsideringAggregates(noTable);
    var joinProps = [];
    if (this.getTo()) {
        joinProps = this.getTo().joinproperties;
    } else {
        var relevantNavigationSegments = this.getRelevantNavigationSegments();
        joinProps = getJoinProperties(relevantNavigationSegments, this._SelectedNavigations);
    }

    return concatJoinProperties(selectedProperties, joinProps, table);
};

function getJoinProperties(relevantNavigationSegments, selectedNavigations) {
    return selectedNavigations.reduce(toJoinProperties, []);

    function toJoinProperties(joinProps, selectedNavigation) {
        var selectedNavigationSegment = relevantNavigationSegments[selectedNavigation];
        if (selectedNavigationSegment) {
            var from = selectedNavigationSegment.getFrom();
            if (from) {
                return joinProps.concat(from.joinproperties);
            }
        }
        return joinProps;
    }
}

DbSegment.prototype.getAllSelectedNonAggregatePropertiesForOrderBy = function (noTable) {
    var table = noTable ? null : this._Alias,
        entityType = this.entityType,
        selectedProperties = this._getSortedSelectProperties();


    if (entityType.hasAggregates()) {
        selectedProperties = selectedProperties.filter(aggregates);
    }

    return selectedProperties.map(toSqlSelectProperty);

    function aggregates(selectedProp) {
        return !entityType.getAggregates().some(withColumnName);

        function withColumnName(aggregate) {
            return aggregate.column === selectedProp;
        }
    }

    function toSqlSelectProperty(selectedProperty) {
        return new sqlStatement.SelectProperty(table, selectedProperty);
    }
};

DbSegment.prototype.getAllSelectedNonAggregateIncludingJoinPropertiesForGroupBy = function (noTable) {
    var table = noTable ? null : this._Alias;
    var selectedProps = this.getAllSelectedNonAggregatePropertiesForOrderBy(noTable, true);
    var joinProps = [];
    if (this.getTo()) {
        joinProps = this.getTo().joinproperties;
    } else {
        var relevantNavigationSegments = this.getRelevantNavigationSegments();
        joinProps = getJoinProperties(relevantNavigationSegments, this._SelectedNavigations);
    }

    return concatJoinProperties(selectedProps, joinProps, table);
};

function concatJoinProperties(selectedProps, joinProps, table) {
    joinProps.forEach(function (joinProp) {
        var shouldAdd = !selectedProps.some(function (selectProp) {
            return selectProp.property === joinProp;
        });

        if (shouldAdd) {
            selectedProps.push(new sqlStatement.SelectProperty(table, joinProp, null));
        }
    });

    return selectedProps;
}

DbSegment.prototype.getNavPropertiesForCreate = function () {
    var ret = [];

    //var properties = this.entityType.properties;
    var properties = this._SelectedNavigations;
    for (var i = 0; i < properties.length; i++) {
        var navPropertyName = properties[i];

        var navDbSeg = this._relevantNavigationSegments[navPropertyName];
        if (!navDbSeg) {
            continue;
        }
        var propertyNames = navDbSeg.getFrom().joinproperties;

        for (var ii = 0; ii < propertyNames.length; ii++) {
            var property = this.entityType.propertiesMap[propertyNames[ii]];
            var propertyName = property.COLUMN_NAME;
            if (this._getSortedSelectProperties().indexOf(propertyName) > -1) {
                continue;
            }
            var typeString = property.DATA_TYPE_NAME;

            if (typeString === 'DECIMAL') {
                typeString += '(' + property.LENGTH.toString() + ',' + property.SCALE.toString() + ')';
            } else if (typeString === 'VARCHAR') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'NVARCHAR') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'ALPHANUM') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'CHAR') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'NCHAR') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'VARBINARY') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'SHORTTEXT') {
                typeString = 'NVARCHAR(10)';
            }
            ret.push(
                new sqlStatement.CreateProperty(propertyName, typeString)
            );
        }
    }
    return ret;
};
DbSegment.prototype.getNavPropertiesForSelect = function (noTable) {
    var ret = [];

    //var properties = this.entityType.properties;
    var properties = this._SelectedNavigations;
    for (var i = 0; i < properties.length; i++) {
        var navPropertyName = properties[i];
        if (this._getSortedSelectProperties().indexOf(navPropertyName) > -1) {
            continue;
        }
        var navDbSeg = this._relevantNavigationSegments[navPropertyName];
        if (!navDbSeg) {
            continue;
        }
        var propertyNames = navDbSeg.getFrom().joinproperties;


        for (var ii = 0; ii < propertyNames.length; ii++) {
            var property = this.entityType.propertiesMap[propertyNames[ii]];
            var propertyName = property.COLUMN_NAME;
            if (this._getSortedSelectProperties().indexOf(propertyName) > -1) {
                continue;
            }

            ret.push(
                new sqlStatement.SelectProperty(noTable ? null : this._Alias, propertyNames[ii], null)
            );
        }
    }
    return ret;
};


/**
 * Returns the key names of used/expanded navigation selectProperty list (containing table alias and key name)
 * For usage in the select part of sql statements
 * @returns {sqlStatement.SelectProperty[]}
 */
DbSegment.prototype.getNonKeyNonSelectedProperties4Expansion = function () {
    //
    var ret = [];
    for (var i = 0; i < this._ExpandedNavigations.length; i++) {
        var exp = this._relevantNavigationSegments[this._ExpandedNavigations[i]];
        var from = exp._end.from;

        for (var ii = 0; ii < from.joinproperties.length; ii++) {
            var joinProperty = from.joinproperties[ii];

            //Non Key
            if (this.entityType.keys.names.indexOf(joinProperty) === -1) {
                if (this._getSortedSelectProperties().indexOf(joinProperty) === -1) {

                    ret.push(
                        new sqlStatement.SelectProperty(this._Alias, joinProperty, null)
                    );
                }
            }
        }
    }
    return ret;
};


/**
 * Returns non key properties as array for usage in the INSERT, UPDATE or CREATE TABLE SQL statements.
 * @returns {sqlStatement.TableColumn[]}
 */
DbSegment.prototype.getQNonKeyProperties = function () {
    var ret = [],
        propertyName;

    for (var i = 0; i < this._getSortedSelectProperties().length; i++) {
        propertyName = this._getSortedSelectProperties()[i];

        if (this.entityType.keys.names.indexOf(propertyName) === -1) {
            ret.push(new sqlStatement.TableColumn(this._Alias, propertyName));
        }
    }
    return ret;
};

/**
 * Returns non key properties as array for usage in a SELECT SQL statement.
 * @returns {sqlStatement.SelectProperty[]}
 */
DbSegment.prototype.getQNonKeyPropertiesForSelect = function () {
    var ret = [],
        propertiesMap = this.entityType.propertiesMap,
        propertyName,
        property,
        propertyType;

    for (var i = 0; i < this._getSortedSelectProperties().length; i++) {
        propertyName = this._getSortedSelectProperties()[i];

        if (this.entityType.keys.names.indexOf(propertyName) === -1) {
            property = propertiesMap[propertyName];
            propertyType = property.aggregate ? null : property.DATA_TYPE_NAME;

            ret.push(new sqlStatement.SelectProperty(this._Alias, propertyName, propertyType, null));
        }
    }
    return ret;
};

/**
 * for this DBSeg, returns the foreign key for prev/next DBSeg
 * */
DbSegment.prototype.getQForeignKeyProperties = function () {
    var ret = [], refDBSeg, fkeys;
    if (this.previousDBSegment) {
        refDBSeg = this.previousDBSegment;
        fkeys = this.getTo().joinproperties;
    } else if (this.nextDBSegment) {
        refDBSeg = this.nextDBSegment;
        fkeys = refDBSeg.getFrom().joinproperties;
    } else {
        // error
    }

    var alias = this._Alias;
    fkeys.forEach(function (fkeyName) {
        ret.push(
            new sqlStatement.SelectProperty(alias, fkeyName, null)
        );
    });

    return ret;
};

/**
 * Returns the key names and values
 * For usage in where clauses
 * @returns {{key : sqlStatement.Property, value : string}[]}
 */
DbSegment.prototype.getQKeyWithValues = function (alias) {
    var ret = [];
    for (var i = 0; i < this._KeyValues.length; i++) {
        var etProperty = this.entityType.propertiesMap[this._KeyValues[i].name];
        if (etProperty.KIND !== EntityType.entityKind.inputParameters) {
            ret.push({
                key: new typedObjects.Property(this._KeyValues[i].name, alias ? alias : this._Alias),
                value: this._KeyValues[i].value
            });
        }
    }
    return ret;
};

DbSegment.prototype.getQKeyWithValuesDB = function (alias) {
    var ret = [];

    for (var i = 0; i < this._KeyValues.length; i++) {

        ret.push({
            key: new typedObjects.Property(this._KeyValues[i].name, alias ? alias : this._Alias),
            value: new typedObjects.DbValue(this._KeyValues[i].value)
        });
    }
    return ret;
};

DbSegment.prototype.getQForeignKeyWithValues = function (alias) {
    var ret = [], refDBSeg, fkeys;
    if (this.previousDBSegment) {
        refDBSeg = this.previousDBSegment;
        fkeys = this.getTo().joinproperties;
    } else if (this.nextDBSegment) {
        refDBSeg = this.nextDBSegment;
        fkeys = refDBSeg.getFrom().joinproperties;
    } else {
        // error
    }

    var a = (alias ? alias : this._Alias);
    fkeys.forEach(function (fkeyName, i) {
        ret.push({
            key: new typedObjects.Property(fkeyName, a),
            value: refDBSeg._KeyValues[i].value
        });
    });

    return ret;
};

DbSegment.prototype.getOverPropertiesWithValues = function () {
    var ret = [], dbSeg, refDBSeg;
    //var a = (alias ? alias : this._Alias);

    if (this.previousDBSegment) {
        refDBSeg = this.previousDBSegment;
        dbSeg = this;
    } else if (this.nextDBSegment) {
        refDBSeg = this.nextDBSegment;
        dbSeg = this;
    }

    var over = this.getOver();

    var keyProp1 = over.principal;
    keyProp1.forEach(function (fkeyName, i) {
        ret.push({
            key: new typedObjects.Property(fkeyName),
            value: refDBSeg._KeyValues[i].value
        });
    });

    var keyProp2 = over.dependent;
    keyProp2.forEach(function (fkeyName, i) {
        ret.push({
            key: new typedObjects.Property(fkeyName),
            value: dbSeg._KeyValues[i].value
        });
    });

    return ret;
};

DbSegment.prototype.dump = function (logger, addText) {
    var text = addText || 'Dbsegment: ';
    var filter = function (key, value) {
        if (key === '__metadata' || key === 'previousDBSegment') {
            return undefined;
        }
        return value;
    };
    logger.debug(text + JSON.stringify(this, filter, 4));
};


/**
 * Add a  navigationDbSegment to the expand tree
 *
 * @param navPropName Name of the expanded navigation property
 * @param navigationDbSegment Corresponding dbSegment
 */
DbSegment.prototype.addExpandDbSegment = function (navPropName, navigationDbSegment) {
    if (this.entityType.navPropertiesMap[navPropName]) {
        navigationDbSegment.isExpand = true;
        this._ExpandedNavigations.push(navPropName);
        this._ExpandedNavigationsDBSeg[navPropName] = navigationDbSegment;
        this._relevantNavigationSegments[navPropName] = navigationDbSegment;
    }
};

DbSegment.prototype.addRelevantNavigationSegment = function (navPropName, dbSeg) {
    if (this.entityType.navPropertiesMap[navPropName]) {
        this._relevantNavigationSegments[navPropName] = dbSeg;
    }
};

DbSegment.prototype.getRelevantNavigationSegments = function () {
    return this._relevantNavigationSegments;
};

/**
 * Adds all properties and navigation propertiy of the dbSegments entityset to the lists:
 * _SelecdtedProperties and _SelectedNavigations
 */
DbSegment.prototype.addAllProperties = function () {
    var i;

    var properties = this.entityType.properties;
    for (i = 0; i < properties.length; i++) {
        this._SelectedProperties.push(properties[i].COLUMN_NAME);
        this._SelectedPropertiesOrdered = null;
    }

    /*add all navigations  in the OData 2.0 Spec (file://dwdf207/PTU_IW/50_Development/Web%202.0%20Communication%20Team/61_OData_Specification_V2.0/%5Bms-odata%5DV2.pdf)
     is written
     If a star appears in a selectItem following a selectedNavProperty, all non-navigation properties of
     the entity or entities represented by the prior selectedNavProperty MUST be included in the
     response.
     However, since ABAP, XS1 and MS add also the navigation properties on star we do the same here too
     */

    properties = this.entityType.navPropertyNames;
    for (i = 0; i < properties.length; i++) {
        var nav = properties[i];
        if (this._SelectedNavigations.indexOf(nav) === -1) {
            this._SelectedNavigations.push(nav);
        }

    }

    this.isGenKeySelected = true;
};

DbSegment.prototype._getSortedSelectProperties = function () {

    if (!this._SelectedPropertiesOrdered) {
        this._SelectedPropertiesOrdered = _.intersection(this.entityType.propertyNames, this._SelectedProperties);
    }

    return this._SelectedPropertiesOrdered;
};

/**
 * Add a property to list _SelectedProperties
 * @param propertyName
 */
DbSegment.prototype.addSelectProperties = function (propertyName) {

    if (this.entityType.keys.generatedKey === propertyName) {
        this.isGenKeySelected = true;
        return;
    }

    //check if property is per service definition included
    if (this.entityType.properties.with) {
        if (this.entityType.properties.with.indexOf(propertyName) > -1) {
            this._SelectedProperties.push(propertyName);
            this._SelectedPropertiesOrdered = null;
            return;
        }
    }

    if (this.entityType.properties.without) {
        if (this.entityType.properties.without.indexOf(propertyName) > -1) {
            throw new Error('Error in $select system query option: selected property is not expanded or does not exist.');
        }
    }

    //check if property is available
    if (this.entityType.propertiesMap[propertyName]) {
        this._SelectedProperties.push(propertyName);
        this._SelectedPropertiesOrdered = null;
        return;
    }

    //check for navigation property
    if (this.entityType.navPropertiesMap[propertyName]) {
        if (this._SelectedNavigations.indexOf(propertyName) === -1) {
            this._SelectedNavigations.push(propertyName);
            return;
        }
    }

    throw(new BadRequest('property "' + propertyName + '" does not exist'));
};

DbSegment.prototype.isNavigationProperty = function (propertyName) {
    return !!this.entityType.navPropertiesMap[propertyName];
};

DbSegment.prototype.getSelectedPropsWithGenKey = function getSelectedPropsWithGenKey() {
    if (this.isGenKeySelected && this.entityType.keys.generatedKey) {
        return [this.entityType.keys.generatedKey].concat(this._getSortedSelectProperties());
    }

    return this._getSortedSelectProperties();
};

/**
 * If a generic key is defined this method clones the rows selected by this dbSegment and adds a generated key.
 * The Cloned rows are returned.
 * @returns {Array}
 */
DbSegment.prototype.getRowsWithGenKey = function getRowsWithGenKey() {
    var genKey = this.entityType.keys.generatedKey;

    if (genKey) {
        if (!this._rowsWithGenKey) {
            this._rowsWithGenKey = this.sql.rows.map(function (row, index) {
                var cloneRow = xsODataUtils.clone(row);
                var genKeyValue = keyGenerator.createGenKeyValue(index);
                cloneRow[genKey] = genKeyValue;
                cloneRow['0'] = genKeyValue;

                return cloneRow;
            });
        }

        return this._rowsWithGenKey;
    }

    return this.sql.rows;
};

DbSegment.prototype.getKeysProperties = function getKeysProperties() {
    var genKey = this.entityType.keys.generatedKey;

    if (genKey) {
        return [keyGenerator.createGenKeyProperty(genKey)];
    }

    return this.entityType.keys.names.map(function toKeysProperties(keyName) {
        return this.entityType.propertiesMap[keyName];
    }.bind(this));

};

/**
 * @param {{name : string, value: string}[]} keyValuePairs
 */
DbSegment.prototype.setKeyValues = function (keyValuePairs) {
    var i;
    var kNV;
    var keyHelperMap = {}; //stores keys with name for easy comparision

    if (nodeUtils.isArray(keyValuePairs)) {
        this._KeyValues = keyValuePairs;

        for (i = 0; i < keyValuePairs.length; i++) {
            kNV = keyValuePairs[i];
            keyHelperMap[kNV.name] = kNV.value;
        }
    } else {
        this._KeyValues = [
            {
                name: this.entityType.keys.names[0],
                value: keyValuePairs
            }
        ];
        keyHelperMap[this.entityType.keys.names[0]] = keyValuePairs;
    }


    //Check if all keys are provided
    var key;
    for (i = 0; i < this.entityType.keys.names.length; i++) {
        key = this.entityType.keys.names[i];
        if (!keyHelperMap[key]) {
            throw new BadRequest('Insufficient key values');
        }
    }

};


DbSegment.prototype.setParameterValues = function (keyValuePairs) {
    if (nodeUtils.isArray(keyValuePairs)) {
        this._ParameterValues = keyValuePairs;
    } else {
        throw new InternalError();
    }
};
DbSegment.prototype.getPropertyInfo = function (property) {
    return this.entityType.propertiesMap[property];
};

DbSegment.prototype.getETag = function getETag(context, callback) {
    var eTagSelectStmt = sqlStatement.createSelectStmtForETag(this);

    dbConnect.connect(context, function (err, context) {
        if (err) {
            return callback(err);
        }

        return getCollector.executeSelect(context, eTagSelectStmt, function (error, dbRows) {
            var eTag,
                entity;

            if (error) {
                return callback(error);
            }

            entity = dbRows[0];
            eTag = entity ? entity["__etag"] : undefined;

            return callback(null, eTag);
        });
    });
};
