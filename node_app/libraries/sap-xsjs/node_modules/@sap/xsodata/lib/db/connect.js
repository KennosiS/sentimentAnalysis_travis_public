'use strict';
/**
 * Add  <db> attribute to <context>
 * Uses <context>.<handlerConfiguration.dbConfiguration>
 * <db> = {
 *     client : hdb-client
 * }
 */

var hdb = require('hdb');
var async = require('async');
var utils = require('./../utils/utils');
var Measurement = require('./../utils/measurement');

var Rwlock = require('rwlock');
var locks = new Rwlock();

var InternalError = require('./../utils/errors/internalError');
var ApplicationError = require('./../utils/errors/applicationError');

/**
 * Executes an sql command on the current db connection
 *
 * @param sql
 * @param context
 * @param asyncDone
 */
function execSQL(sql, context, asyncDone) {
    context.logger.silly('db', 'exec sql ' + sql);
    context.db.client.exec(sql, function (err) {
        return asyncDone(err, context);
    });
}

/**
 * Sets the schema and isolation level on the current db connection
 *
 * @param context
 * @param asyncDone
 */
function prepareConnection(context, asyncDone) {

    var executeList = [
        utils.injectContext(context)
    ];

    // Set the default schema
    if (context.defaultSchema) {
        executeList.push(utils.tryAndMeasure(execSQL, 'SET SCHEMA ' + context.defaultSchema, 'execSQL (default schema)'));
    }

    // Set the isolation level
    executeList.push(utils.tryAndMeasure(execSQL, 'SET TRANSACTION ISOLATION LEVEL REPEATABLE READ', 'execSQL (isolation level)'));

    async.waterfall(
        executeList,
        function (err) {
            context.db.client.setAutoCommit(false);
            asyncDone(err, context);
        }
    );
}

/**
 * Calls the callback function used by the application to open the cb connection only on demand
 *
 * @param context
 * @param asyncDone
 * @private
 */
exports._openConnection = function (context, asyncDone) {
    context.db.opener(context.handlerConfiguration.dbConfiguration, function (err, newClient) {
        if (err) {
            return asyncDone(new ApplicationError('Internal error occurred', err));
        }
        context.db.client = newClient;

        return prepareConnection(context, asyncDone);
    });
};


/**
 * Connects to a database, there are 3 way to define which database
 * 1. By providing a hdbClient via requestOptions.dbClient
 * 2. By providing a callback function to open the connection via requestOptions.dbOpenCB
 * 3. By providing the dbConfiguration which is passed to the hdb module
 *
 * @param context
 * @param asyncDone
 * @returns {*}
 * @private
 */
function _connectInternal(context, asyncDone) {
    var client;
    context.logger.silly('db', '_connectInternal');
    context.db.isExternalHandledConnection = false;
    if (context.db) {
        if (context.db.client) {
            //use existing db client
            context.db.isExternalHandledConnection = true; // indicator for temp table truncation/drop
            return prepareConnection(context, asyncDone);
        } else if (context.db.opener) {
            context.db.isExternalHandledConnection = true; // indicator for temp table truncation/drop
            return exports._openConnection(context, asyncDone);
        }
    }


    try {
        client = Measurement.measureSync(hdb.createClient, context.handlerConfiguration.dbConfiguration, 'hdb.createClient');

    } catch (exception) {
        context.logger.error('db', 'createClient failed: ' + JSON.stringify(exception));
        return asyncDone(exception);
    }

    client.on('error', function (err) {
        context.logger.error('db', 'client error event: ' + JSON.stringify(err));
        return asyncDone(new InternalError(err, context), context);
    });

    if (Measurement.isActive()) {
        /* perform an explicit measurement:
         * extract the current parent from the global stack
         * assign a new child: implicitly starts a counter, is used later to stop the counter
         */
        var parent = Measurement.getRunningMeasurement();
        var child = parent.newChild('client.connect');
        child.counterStart();
    }
    client.connect(function (err) {
        if (Measurement.isActive()) {
            child.counterStop();
        }

        if (err) {
            context.logger.error('db', 'connect failed: ' + JSON.stringify(err));
            client.end();
            return asyncDone(new InternalError(err, context), context);
        }

        context.db.client = client;
        context.db.openedConnection = true;

        context.logger.info('db', 'connection opened');
        return prepareConnection(context, asyncDone);
    });
}

/**
 * Open and configures the db connection
 *
 * @param context
 * @param asyncDone
 * @returns {*}
 */
exports.connect = function (context, asyncDone) {
    context.logger.debug('db', 'connect');
    context.db = context.db || {};
    if (context.db.client && (context.db.connectionInitialized === true)) {
        return asyncDone(null, context);
    }

    locks.writeLock('db_open', function (release) {
        return _connectInternal(context, function (err) {
            context.logger.debug('db', 'connection is usable');
            context.db.connectionInitialized = true;
            release();
            return asyncDone(err, context);
        });

    });
};


/**
 * Ends the db connection
 *
 * @param context
 */
exports.disconnect = function (context) {
    context.db = context.db || {};
    if (context.db.openedConnection) {
        context.logger.info('db', 'disconnect');
        if (context.db.client) {
            context.db.client.end();
        }
        context.db.openedConnection = false;
    }
};



