'use strict';

var async = require('async');
var sqlDeleteLinks = require('./../sql/createDeleteLinksStatements');
var dataCollectorLinks = require('./../sql/dataCollectorLinks');
var dataCollectorDeleteLinks = require('./../sql/dataCollectorDeleteLinks');
var DBSegment =  require('./../db/dbSegment');
var serializer = require('./../serializer/serializer');
var exitProcessor = require('./exitProcessor');
var utils = require('./../utils/utils');
//var contenTypeCheck = require('./../utils/checkContentType');
//var UnsupportedMediaType = require('./../utils/errors/http/unsupportedMediaType');

function movePayloadToDbSegment(context, asyncDone) {

    DBSegment.DbSegment.setRecordDeleteLinks(context);

    return asyncDone(null, context);
}


function eventBefore(context, asyncDone) {
	var eventFunction = exitProcessor.eventHandler('before', 'delete');

	context.logger.info('delete', 'event start before');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'before');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventAfter(context, asyncDone) {
	var eventFunction = exitProcessor.eventHandler('after', 'delete');

	context.logger.info('delete', 'event start after');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'after');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPrecommit(context, asyncDone) {
	var eventFunction = exitProcessor.eventHandler('precommit', 'delete');

	context.logger.info('delete', 'event start precommit');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'precommit');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPostcommit(context, asyncDone) {
	var eventFunction = exitProcessor.eventHandler('postcommit', 'delete');

	context.logger.info('delete', 'event start postcommit');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'postcommit');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function insertTmpTableToRealTable(context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    var entityType = dbSeg.entityType;
    var create = (entityType.modifications || {} ).update || {};

    if (create.using) {
        exitProcessor.executeExit(create.using, 'using', 'delete', context, asyncDone);
    } else {
        dataCollectorLinks.insertTmpTableToRealTable(context, asyncDone);
    }
}

function executeDelete(context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    var entityType = dbSeg.entityType;
    var _delete = (entityType.modifications || {} )['delete'] || {};
    if (_delete.using) {
        exitProcessor.executeExit(_delete.using, 'using', 'delete', context, asyncDone);
    } else {
        dataCollectorDeleteLinks.deleteTable(context, asyncDone);
    }
}

function setStatus(context, asyncDone) {
    context.response.status(204);
    return asyncDone(null, context);
}

exports.process = function (context, asyncDone) {
    var execArr;
	var m2n = (context.oData.dbSegmentLast.getOver()!==undefined);

	context.logger.silly('resourceprocessor', 'process_Delete');

	if (m2n) { // INSERT into 3rd table
        context.oData.dbSegmentLast.m2n = true;
        execArr = [
            utils.injectContext(context),

            //preparation
            utils.try(sqlDeleteLinks.createDeleteLinksMNStatements),
            utils.try(dataCollectorLinks.createTmpTableMN), //create //NEW ORL
            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorDeleteLinks.insertDataToDelTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(executeDelete),
            utils.try(eventAfter),

            //commit handling
            utils.try(eventPrecommit),
            utils.try(dataCollectorLinks.commit),
            utils.try(eventPostcommit),

            // truncate temporary tables to clean the session
            utils.try(dataCollectorLinks.truncateTempTablesMN),

            // drop temporary tables to clean the session
            utils.try(dataCollectorLinks.dropTempTablesMN),

            utils.try(setStatus)
        ];
    } else {
        execArr = [
            utils.injectContext(context),

            //preparation
            utils.try(movePayloadToDbSegment),
            utils.try(sqlDeleteLinks.createDeleteLinksStatements),
            utils.try(dataCollectorLinks.movePayloadFromSegmentToSelectStm), //no change
            utils.try(dataCollectorLinks.createTmpTable), //create //NEW ORL
            utils.try(dataCollectorLinks.insertOldDataToOldTable),
            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorLinks.insertPayloadIntoTempTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealTable),
            utils.try(eventAfter),

            //commit handling
            utils.try(eventPrecommit),
            utils.try(dataCollectorLinks.commit),
            utils.try(eventPostcommit),

            // truncate temporary tables to clean the session
            utils.try(dataCollectorLinks.truncateTempTables),

            // drop temporary tables to clean the session
            utils.try(dataCollectorLinks.dropTempTables),

            //post processing
            utils.try(serializer.serializeNoContent)
        ];
    }

    async.waterfall(
        execArr,
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchCreateTables = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_Delete');

    var execArr;
    var m2n = (context.oData.dbSegmentLast.getOver()!==undefined);
    if (m2n) { // INSERT into 3rd table
        context.oData.dbSegmentLast.m2n = true;
        execArr = [
            utils.injectContext(context),

            //preparation
            utils.try(sqlDeleteLinks.createDeleteLinksMNStatements),
            utils.try(dataCollectorLinks.createTmpTableMN)
        ];
    }
    else {
        execArr = [
            utils.injectContext(context),

            //preparation
            utils.try(movePayloadToDbSegment),
            utils.try(sqlDeleteLinks.createDeleteLinksStatements),
            utils.try(dataCollectorLinks.movePayloadFromSegmentToSelectStm), //no change
            utils.try(dataCollectorLinks.createTmpTable) //create //NEW ORL
        ];
    }

    async.waterfall(
        execArr,
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatch = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_Delete');

    var execArr;
    var m2n = (context.oData.dbSegmentLast.getOver()!==undefined);
    if (m2n) { // INSERT into 3rd table
        context.oData.dbSegmentLast.m2n = true;
        execArr = [
            utils.injectContext(context),

            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorDeleteLinks.insertDataToDelTable),

            //execution
            utils.try(eventBefore),
            utils.try(executeDelete), //insert real
            utils.try(eventAfter)
        ];
    }
    else {
        execArr = [
            utils.injectContext(context),

            utils.try(dataCollectorLinks.insertOldDataToOldTable),
            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorLinks.insertPayloadIntoTempTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealTable),
            utils.try(eventAfter)
        ];
    }

    async.waterfall(
        execArr,
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchPreCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_Delete');

    async.waterfall(
        [
            utils.injectContext(context),
            utils.try(eventPrecommit)
        ],

        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatchPostCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_Delete');

    async.waterfall(
        [
            utils.injectContext(context),
            utils.try(eventPostcommit),

            // truncate temporary tables to clean the session
            utils.try(dataCollectorLinks.truncateTempTables),

            // drop temporary tables to clean the session
            utils.try(dataCollectorLinks.dropTempTables),

            //post processing
            utils.try(serializer.serializeNoContent)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};
