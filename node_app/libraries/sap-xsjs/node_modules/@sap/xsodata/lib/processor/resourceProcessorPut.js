'use strict';

var async = require('async');
var sqlPut = require('./../sql/createPutStatements');
var dataCollectorPut = require('./../sql/dataCollectorPut');
var dataCollectorGet = require('./../sql/dataCollectorGet');

var serializer = require('./../serializer/serializer');
var exitProcessor = require('./exitProcessor');
var utils = require('./../utils/utils');
var contenTypeCheck = require('./../utils/checkContentType');

var UnsupportedMediaType = require('./../utils/errors/http/unsupportedMediaType');
var AtomXmlSerializer = require('./../serializer/atomXmlToJsonSerializer');
var InternalError = require('./../utils/errors/internalError');
var BadRequestError = require('./../utils/errors/http/badRequest');


function movePayloadToDbSegment(context, asyncDone) {

    var req = context.request;
    var contentType = req.headers['content-type'];

    try {

        context.logger.silly('resourceProcessorPost', 'movePayloadToDbSegment');

        if (contentType) {

            var isSupportedContentType =
                contenTypeCheck.isSupportedContentType(contentType);

            if (isSupportedContentType === false) {
                throw new UnsupportedMediaType('Content-Type ' + contentType + ' not supported.');
            }

        } else {
            throw new UnsupportedMediaType("The server is refusing to process the request because"+
                " the entity has an unsupported format", context);
        }

        if (req.body) {
            //SAPINFO This IF covers the Express case. The Express module sets the body in the request object
            onData(req.body);
        } else {
            req.getBodyAsString(onData);
        }
    } catch (err) {
        return asyncDone(err, context);
    }

    function onData(buffer) {

        try {

            var dbSeg = context.oData.dbSegmentLast;

            var data = buffer.toString('utf-8');

            if (contenTypeCheck.isContentTypeXml(contentType) === true && utils.isXml(data) === true) {

                var typeModel = dbSeg.entityType.propertiesMap;

                var serializer = new AtomXmlSerializer(data, typeModel);

                return serializer
                    .serialize(function (err, innerContext) {

                        if (err) {
                            return asyncDone(err, context);
                        }

                        if (!Array.isArray(innerContext.result)) {
                            var err1 = InternalError("Serialization result is not an array", context);
                            return asyncDone(err1, context);
                        }

                        var len = innerContext.result.length;
                        if (len !== 1) {
                            var err2 = InternalError("Serialization result length must be 1 but is "+len, context);
                            return asyncDone(err2, context);
                        }

                        var result = innerContext.result[0];

                        dbSeg.setRecordPUT(context, result);

                        return asyncDone(null, context);

                    });

            }

            if (contenTypeCheck.isContentTypeJson(contentType) === true) {
                var json;

                try {
                    json = JSON.parse(data);
                } catch (e) {
                    return asyncDone(new BadRequestError("Request payload is not a valid json" +
                        " object", context));
                }

                try {
                    dbSeg.setRecordPUT(context, json);
                    return asyncDone(null, context);
                } catch (err) {
                    return asyncDone(err, context);
                }
            }

            // If we reach this code no valid content type could be found
            // or the payload is not valid
            throw new UnsupportedMediaType('Content-Type ' + contentType + ' does not match payload: ' + data);


        } catch (err) {
            return asyncDone(err, context);
        }

        return asyncDone(null, context);
    }


}


function eventBefore(context, asyncDone) {
    context.logger.info('update', 'event start before');
    var eventFunction = exitProcessor.eventHandler('before', 'update');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'before');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventAfter(context, asyncDone) {
    context.logger.info('update', 'event start after');
    var eventFunction = exitProcessor.eventHandler('after', 'update');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'after');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPrecommit(context, asyncDone) {
    context.logger.info('update', 'event start precommit');
    var eventFunction = exitProcessor.eventHandler('precommit', 'update');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'precommit');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPostcommit(context, asyncDone) {
    context.logger.info('update', 'event start postcommit');
    var eventFunction = exitProcessor.eventHandler('postcommit', 'update');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'postcommit');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}
function insertTmpTableToRealTable(context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    var entityType = dbSeg.entityType;
    var create = (entityType.modifications || {} ).update || {};

    if (create.using) {
        exitProcessor.executeExit(create.using, 'using', 'update', context, asyncDone);
    } else {
        dataCollectorPut.insertTmpTableToRealTable(context, asyncDone);
    }
}

exports.process = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_PUT');

    async.waterfall(
        [
            utils.injectContext(context),

            //preparation
            utils.try(movePayloadToDbSegment),
            utils.try(sqlPut.createPutStatements),
            utils.try(dataCollectorPut.movePayloadFromSegmentToSelectStm), //no change
            utils.try(dataCollectorPut.createTmpTable), //create //NEW ORL
            utils.try(dataCollectorPut.insertOldDataToOldTable),
            utils.try(dataCollectorPut.insertPayloadIntoTempTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealTable),
            utils.try(eventAfter),

            //commit handling
            utils.try(eventPrecommit),
            utils.try(dataCollectorPut.commit),
            utils.try(eventPostcommit),

            // truncate temporary tables to clean the session
            utils.try(dataCollectorPut.truncateTempTables),

            // drop temporary tables to clean the session
            utils.try(dataCollectorPut.dropTempTables),

	        // select ETag
            utils.try(dataCollectorGet.select),

            //post processing
            utils.try(serializer.serializeNoContent)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchCreateTables = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_PUT');

    async.waterfall(
        [
            utils.injectContext(context),

            //preparation
            utils.try(movePayloadToDbSegment),
            utils.try(sqlPut.createPutStatements),
            utils.try(dataCollectorPut.movePayloadFromSegmentToSelectStm), //no change
            utils.try(dataCollectorPut.createTmpTable) //create //NEW ORL
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatch = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_PUT');

    async.waterfall(
        [
            utils.injectContext(context),

            utils.try(dataCollectorPut.insertOldDataToOldTable),
            utils.try(dataCollectorPut.insertPayloadIntoTempTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealTable),
            utils.try(eventAfter),

	        // select ETag
	        utils.try(dataCollectorGet.select)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchPreCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_PUT');

    async.waterfall(
        [
            utils.injectContext(context),

            //commit handling
            utils.try(eventPrecommit)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatchPostCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_PUT');

    async.waterfall(
        [
            utils.injectContext(context),

            utils.try(eventPostcommit),

            // truncate temporary tables to clean the session
            utils.try(dataCollectorPut.truncateTempTables),

            // drop temporary tables to clean the session
            utils.try(dataCollectorPut.dropTempTables),

            //post processing
            utils.try(serializer.serializeNoContent)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};
