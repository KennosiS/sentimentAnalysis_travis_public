'use strict';
var async = require('async');


var utils = require('./../utils/utils');
var sqlDelete = require('./../sql/createDeleteStatements');
var dataCollectorDelete = require('./../sql/dataCollectorDelete');
var serializer = require('./../serializer/serializer');
var exitProcessor = require('./exitProcessor');
var Http404_NotFound = require('./../utils/errors/http/notFound');

function eventBefore(context, asyncDone) {
    context.logger.info('delete', 'event start before');
    var eventFunction = exitProcessor.eventHandler('before', 'delete');
    eventFunction(context, function (err, context) {
        context.logger.info('delete event end', 'before');
        if (err) {
            context.logger.info('delete event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventAfter(context, asyncDone) {
    context.logger.info('delete', 'event start after');
    var eventFunction = exitProcessor.eventHandler('after', 'delete');
    eventFunction(context, function (err, context) {
        context.logger.info('delete event end', 'after');
        if (err) {
            context.logger.info('delete event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPrecommit(context, asyncDone) {
    context.logger.info('delete', 'event start precommit');
    var eventFunction = exitProcessor.eventHandler('precommit', 'delete');
    eventFunction(context, function (err, context) {
        context.logger.info('delete event end', 'precommit');
        if (err) {
            context.logger.info('delete event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPostcommit(context, asyncDone) {
    context.logger.info('delete', 'event start postcommit');
    var eventFunction = exitProcessor.eventHandler('postcommit', 'delete');
    eventFunction(context, function (err, context) {
        context.logger.info('delete event end', 'postcommit');
        if (err) {
            context.logger.info('delete event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}


function executeDelete(context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    var entityType = dbSeg.entityType;
    var _delete = (entityType.modifications || {} )['delete'] || {};
    if (_delete.using) {
        exitProcessor.executeExit(_delete.using, 'using', 'delete', context, asyncDone);
    } else {
        dataCollectorDelete.deleteTable(context, asyncDone);
    }
}

function commit(context, asyncDone) {
    return dataCollectorDelete.commit(context, asyncDone);
}

/**
 * dataCollectorDelete.insertDataToDelTable fetches the entity to be deleted, and inserts it into a temp table.
 * It calls dataCollector.execParallelNoResultwithParam, which asynchronously returns
 * asyncDone(err, context, affectedRows)
 * Therefore, before starting the execution, this function checks the affectedRows of the fetched temp entity
 * */
function checkExistence(context, affectedRows, asyncDone) {
    if (affectedRows===0) {
        return asyncDone(new Http404_NotFound('The specified entity to be deleted does not exist.'), context);
    }
    return asyncDone(null, context);
}

exports.process = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_DELETE');

    async.waterfall(
        [
            utils.injectContext(context),

            //preparation
            utils.try(sqlDelete.createDeleteStatements),
            utils.try(dataCollectorDelete.createTmpTable),
            utils.try(dataCollectorDelete.insertDataToDelTable),
            utils.try(checkExistence),

            //execution
            utils.try(eventBefore),
            utils.try(executeDelete),
            utils.try(eventAfter),

            //commit handling
            utils.try(eventPrecommit),
            utils.try(commit),
            utils.try(eventPostcommit),

            // truncate temporary tables to clean the session
            utils.try(dataCollectorDelete.truncateTempTables),

            // drop temporary tables to clean the session
            utils.try(dataCollectorDelete.dropTempTables),

            //post processing
            utils.try(serializer.serializeNoContent)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchCreateTables = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_DELETE');

    async.waterfall(
        [
            utils.injectContext(context),

            //preparation
            utils.try(sqlDelete.createDeleteStatements),
            utils.try(dataCollectorDelete.createTmpTable)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatch = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'process_DELETE');

    async.waterfall(
        [
            utils.injectContext(context),

            //preparation


            utils.try(dataCollectorDelete.insertDataToDelTable),
            utils.try(checkExistence),

            //execution
            utils.try(eventBefore),
            utils.try(executeDelete),
            utils.try(eventAfter)

            //no commit handling
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchPreCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'processBatchCommitRun');
    async.waterfall(
        [
            utils.injectContext(context),

            utils.try(eventPrecommit)
        ],

        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatchPostCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceprocessor', 'processBatchCommitRun');
    async.waterfall(
        [
            utils.injectContext(context),

            utils.try(eventPostcommit),

            // truncate temporary tables to clean the session
            utils.try(dataCollectorDelete.truncateTempTables),

            // drop temporary tables to clean the session
            utils.try(dataCollectorDelete.dropTempTables),

            //post processing
            utils.try(serializer.serializeNoContent)
        ],

        function (err, context) {
            return asyncDone(err, context);
        }
    );
};
