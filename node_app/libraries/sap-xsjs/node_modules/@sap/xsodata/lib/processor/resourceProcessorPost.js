'use strict';

var utils = require('./../utils/utils');
var async = require('async');
var sqlPost = require('./../sql/createPostStatements');
var dataCollectorPost = require('./../sql/dataCollectorPost');
var serializer = require('./../serializer/serializer');
var exitProcessor = require('./exitProcessor');
var typeConv = require('./../utils/typeConverter');
var contenTypeCheck = require('./../utils/checkContentType');
var UnsupportedMediaType = require('./../utils/errors/http/unsupportedMediaType');
var AtomXmlSerializer = require('./../serializer/atomXmlToJsonSerializer');
var InternalError = require('./../utils/errors/internalError');
var BadRequestError = require('./../utils/errors/http/badRequest');


function movePayloadToDbSegment(context, asyncDone) {

    var req = context.request;
    var contentType = req.headers['content-type'];

    try {
        context.logger.silly('resourceProcessorPost', 'movePayloadToDbSegment');

        if (contentType) {

            var isSupportedContentType =
                contenTypeCheck.isSupportedContentType(contentType);

            if (isSupportedContentType === false) {
                throw new UnsupportedMediaType('Content-Type ' + contentType + ' not supported.');
            }

        }

        if (req.body) {
            //SAPINFO This IF covers the Express case. The Express module sets the body in the request object
            onData(req.body);
        } else {
            req.getBodyAsString(onData);
        }
    } catch (err) {
        return asyncDone(err, context);
    }

    function onData(buffer) {

        try {

            var dbSeg = context.oData.dbSegmentLast;

            var data = buffer.toString('utf-8');

            if (contenTypeCheck.isContentTypeXml(contentType) === true && utils.isXml(data) === true) {

                var typeModel = dbSeg.entityType.propertiesMap;

                var serializer = new AtomXmlSerializer(data, typeModel);

                return serializer
                    .serialize(function (err, innerContext) {

                        if (err) {
                            return asyncDone(err, context);
                        }

                        if (!Array.isArray(innerContext.result)) {
                            var err1 = new InternalError("Serialization result is not an array", context);
                            return asyncDone(err1, context);
                        }

                        var len = innerContext.result.length;
                        if (len !== 1) {
                            var err2 = new InternalError("Serialization result length must be 1 but is " + len, context);
                            return asyncDone(err2, context);
                        }

                        var result = innerContext.result[0];

                        dbSeg.setRecordPOST(context, result);

                        return asyncDone(null, context);

                    });

            }

            if (contenTypeCheck.isContentTypeJson(contentType) === true) {
                var json;

                try {
                    json = JSON.parse(data);
                } catch (e) {
                    return asyncDone(new BadRequestError("Request payload is not a valid json" +
                        " object", context));
                }

                try {
                    dbSeg.setRecordPOST(context, json);
                    return asyncDone(null, context);
                } catch (err) {
                    return asyncDone(err, context);
                }
            }

            // If we reach this code no valid content type could be found
            // or the payload is not valid
            throw new UnsupportedMediaType('Content-Type ' + contentType + ' does not match payload.', context);


        } catch (err) {
            return asyncDone(err, context);
        }

        return asyncDone(null, context);
    }

}

function modifyDbSegment(context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    //The dbSegments are build by URL so the last segment for a POST request is a collection.
    //But the returned value from a POST request is the newly created entity, so the last dbsegments
    //must be switched to by a collection to make the serialization work (the _KeyValues of the dbsegment are
    //filled properly before in movePayloadToDbSegment->setRecordPOST
    dbSeg.isCollection = false;
    return asyncDone(null, context);
}


function insertTmpTableToRealTable(context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    var entityType = dbSeg.entityType;
    var create = (entityType.modifications || {} ).create || {};
    if (create.using) {
        exitProcessor.executeExit(create.using, 'using', 'create', context, asyncDone);
    } else {
        dataCollectorPost.insertTmpTableToRealTable(context, asyncDone);
    }
}

function eventBefore(context, asyncDone) {
    context.logger.info('create', 'event start before');
    var eventFunction = exitProcessor.eventHandler('before', 'create');
    eventFunction(context, function (err, context) {
        context.logger.info('create event end', 'before');
        if (err) {
            context.logger.info('create event end', 'error occurred');
        }
        return asyncDone(err, context);
    });
}

function eventAfter(context, asyncDone) {
    context.logger.info('create', 'event start after');
    var eventFunction = exitProcessor.eventHandler('after', 'create');
    eventFunction(context, function (err, context) {
        context.logger.info('create event end', 'after');
        if (err) {
            context.logger.info('create event end', 'error occurred');
        }
        return asyncDone(err, context);
    });
}

function eventPrecommit(context, asyncDone) {
    context.logger.info('create', 'event start precommit');
    var eventFunction = exitProcessor.eventHandler('precommit', 'create');
    eventFunction(context, function (err, context) {
        context.logger.info('create event end', 'precommit');
        if (err) {
            context.logger.info('create event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPostcommit(context, asyncDone) {
    context.logger.info('create', 'event start postcommit');
    var eventFunction = exitProcessor.eventHandler('postcommit', 'create');
    eventFunction(context, function (err, context) {
        context.logger.info('create event end', 'postcommit');
        if (err) {
            context.logger.info('create event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}
function writeContextID(context, asyncDone) {
    try {
        var location = context.oData.dbSegmentLast.entityType.name;
        var keysProperties = context.oData.dbSegmentLast.getKeysProperties();
        //var rows = context.oData.dbSegmentLast.getRowsWithGenKey();
        //var row = rows[0];

        location += '(';
        location += keysProperties.map(toValues).join(',');
        location += ')';


        //contentId
        context.contentId = location;
        //Location header

        return asyncDone(null, context);
    } catch (err) {
        return asyncDone(err, context);
    }

    function toValues(keyProperty, index, array) {
        var dbSeg = context.oData.dbSegmentLast;
        //_recordNV
        //var value = typeConv.serializeDbValueToUriLiteral(row[index.toString()]/*keys[index]*/, keyProperty);
        var value = typeConv.serializeDbValueToUriLiteral(dbSeg._recordMap[keyProperty.COLUMN_NAME], keyProperty);
        if (array.length === 1) {
            return value;
        }

        return keyProperty.COLUMN_NAME + '=' + value;
    }
}

function setStatus(context, asyncDone) {
    context.response.status(201);
    return asyncDone(null, context);
}

function writeLocationHeader(context, asyncDone) {
    try {
        var location = context.oData.dbSegmentLast.entityType.name;
        var keysProperties = context.oData.dbSegmentLast.getKeysProperties();
        var rows = context.oData.dbSegmentLast.getRowsWithGenKey();
        var row = rows[0];

        location += '(';
        location += keysProperties.map(toValues).join(',');
        location += ')';


        //contentId
        //context.contentId = location;
        //Location header
        context.response.setHeader("location", context.uriTree.baseUrl + location);
        return asyncDone(null, context);
    } catch (err) {
        return asyncDone(err, context);
    }

    function toValues(keyProperty, index, array) {
        var value = typeConv.serializeDbValueToUriLiteral(row[index.toString()]/*keys[index]*/, keyProperty);
        if (array.length === 1) {
            return value;
        }

        return keyProperty.COLUMN_NAME + '=' + value;
    }
}

exports.process = function (context, asyncDone) {
    context.logger.silly('resourceProcessorPost', 'process');

    async.waterfall(
        [
            utils.injectContext(context),

            //preparation
            utils.try(movePayloadToDbSegment),
            utils.try(sqlPost.createPostStatements),
            utils.try(dataCollectorPost.movePayloadFromSegmentToSelectStm), //no change
            utils.try(dataCollectorPost.createTmpTable), //create //NEW ORL
            utils.try(dataCollectorPost.insertPayloadIntoTempTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealTable), //insert real
            utils.try(eventAfter),

            //post processing
            utils.try(dataCollectorPost.selectData), //select

            //commit handling
            utils.try(eventPrecommit),
            utils.try(dataCollectorPost.commit),
            utils.try(eventPostcommit),

            // truncate temporary tables to clean the session
            utils.try(dataCollectorPost.truncateTempTables),

            // drop temporary tables to clean the session
            utils.try(dataCollectorPost.dropTempTables),

            utils.try(modifyDbSegment),
            utils.try(writeLocationHeader),
            utils.try(serializer.serializeData),
            utils.try(setStatus)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatchCreateTables = function (context, asyncDone) {
    context.logger.silly('resourceProcessorPost', 'process');

    async.waterfall(
        [
            utils.injectContext(context),

            //preparation
            utils.try(movePayloadToDbSegment),
            utils.try(sqlPost.createPostStatements),
            utils.try(dataCollectorPost.movePayloadFromSegmentToSelectStm), //no change
            utils.try(dataCollectorPost.createTmpTable), //create //NEW ORL
            utils.try(writeContextID)

        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};
exports.processInBatch = function (context, asyncDone) {
    context.logger.silly('resourceProcessorPost', 'process');

    async.waterfall(
        [
            utils.injectContext(context),
            //preparation
            utils.try(dataCollectorPost.insertPayloadIntoTempTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealTable), //insert real
            utils.try(eventAfter),

            //post processing
            utils.try(dataCollectorPost.selectData)//select
            //no commit handling


        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatchPreCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceProcessorPost', 'process');

    async.waterfall(
        [
            utils.injectContext(context),
            utils.try(eventPrecommit)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchPostCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceProcessorPost', 'process');

    async.waterfall(
        [
            utils.injectContext(context),

            utils.try(eventPostcommit),

            // truncate temporary tables to clean the session
            utils.try(dataCollectorPost.truncateTempTables),

            // drop temporary tables to clean the session
            utils.try(dataCollectorPost.dropTempTables),

            utils.try(modifyDbSegment),
            utils.try(writeLocationHeader),
            utils.try(serializer.serializeData),
            utils.try(setStatus)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};
