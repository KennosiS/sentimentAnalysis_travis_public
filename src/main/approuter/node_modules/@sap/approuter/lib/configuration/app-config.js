'use strict';

var _ = require('lodash');
var fs = require('fs');
var path = require('path');
var VError = require('verror').VError;
var safeRegex = require('safe-regex');
var loggingUtils = require('../utils/logger');
var tracer = loggingUtils.getTracer();
var logger = loggingUtils.getLogger('/Configuration');
var fsUtils = require('../utils/fs-utils');
var validators = require('./validators');
var prettyPrint = require('../utils/pretty-print');
var configurationUtils = require('../utils/configuration-utils');

exports.loadConfiguration = function (directory, source, envDestinations, appName) {
  var configuration = _.isObject(source) ? source : loadXsAppFromFile(directory, source);
  validators.validateXsApp(configuration, envDestinations, directory);
  if (configuration.authenticationMethod === 'none') {
    logger.warning('No authentication will be used when accessing backends. Scopes defined in routes will be ignored.');
  }

  configuration.routes = configuration.routes || [];
  var hasLocalDirSet = configuration.routes.some(function (currentRoute) {
    return !!currentRoute.localDir;
  });

  if (!hasLocalDirSet) {
    if (fsUtils.isDirectory(path.join(directory, 'resources'))) {
      configuration.routes.push({
        source: '^/(.*)',
        localDir: 'resources'
      });
    } else {
      logger.info('xs-app.json: Application does not have directory for static resources!');
    }
  }

  processRoutes(configuration, appName);
  handleReplace(configuration);
  configuration.errorPage = generateErrorPageMap(configuration);
  return configuration;
};

function loadXsAppFromFile(directory, source) {
  var fullFileName = path.join(directory, source);

  try {
    tracer.info('Loading configuration from ', fullFileName);
    return JSON.parse(fs.readFileSync(fullFileName, 'utf8'));
  } catch (e) {
    throw new VError(e, 'Invalid content in %s', fullFileName);
  }
}

function generateErrorPageMap(configuration) {
  return (configuration.errorPage || []).reduce(function (result, errorRoute) {
    var arr = Array.isArray(errorRoute.status) ? errorRoute.status : [errorRoute.status];
    arr.forEach(function (status) {
      result.set(status, errorRoute.file);
    });
    return result;
  }, new Map());
}

function handleReplace(configuration) {
  configuration.routes.forEach(function (route) {
    if (route.replace) {
      route.replace.varsMap = route.replace.vars.reduce(function (result, varName) {
        result[varName] = process.env[varName];
        return result;
      }, {});
    }
  });
}

function processRoutes(configuration, appName) {
  if (!appName) {
    logger.info("Replacing $XSAPPNAME will not take place - 'xsappname' property not found in UAA configuration.");
  }

  configuration.routes.forEach(function (currentRoute) {
    currentRoute.source = configurationUtils.constructRegExp(currentRoute.source);
    if (!safeRegex(currentRoute.source)) {
      logger.warning('Route with source ', currentRoute.source, ' is vulnerable to ReDoS attacks');
    }
    if (currentRoute.authenticationType === 'none' && currentRoute.scope) {
      logger.warning('Route with source ', currentRoute.source, ' does not require authentication. Defined scopes will be ignored.');
    }
    currentRoute.scope = processScope(currentRoute.scope, appName);
  });
  if (tracer.isEnabled('debug')) {
    tracer.debug('Routes after being processed', JSON.stringify(configuration.routes, prettyPrint.prettyPrintRegExp, 2));
  }
}

function processScope(scope, appName) {
  if (_.isString(scope) || Array.isArray(scope)) {
    return replaceApplicationName(scope, appName);
  }
  for (var httpMethod in scope) {
    scope[httpMethod] = replaceApplicationName(scope[httpMethod], appName);
  }
  return scope;
}

function replaceApplicationName(scope, appName) {
  scope = _.isString(scope) ? [scope] : scope;
  if (!appName) {
    return scope;
  }
  return scope.map(function (scopeName) {
    return scopeName.replace(/^\$XSAPPNAME/, appName);
  });
}
